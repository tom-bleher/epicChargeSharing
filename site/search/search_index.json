{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"epicChargeSharing","text":"<p>GEANT4-based Monte Carlo simulation for studying spatial charge sharing in AC-LGAD pixel detectors.</p>"},{"location":"#overview","title":"Overview","text":"<p>epicChargeSharing simulates how charge from particle interactions distributes across neighboring pixels in segmented AC-LGAD (Resistive AC-Coupled Low Gain Avalanche Detectors) sensors. It implements the analytical model from Tornago et al. (arXiv:2007.09528).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Physics-based model \u2014 Implements peer-reviewed Tornago charge sharing model</li> <li>Multiple reconstruction methods \u2014 LogA, LinA, and DPC algorithms</li> <li>ROOT integration \u2014 Comprehensive TTree output with metadata</li> <li>Multithreaded \u2014 Native GEANT4 parallel processing</li> <li>Configurable \u2014 Modular geometry, physics, and noise parameters</li> <li>Analysis tools \u2014 Python scripts and ROOT macros included</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Clone and build\ngit clone https://github.com/tom-bleher/epicChargeSharing.git\ncd epicChargeSharing\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake -j$(nproc)\n\n# Run simulation\n./epicChargeSharing -m ../macros/run.mac\n</code></pre> <p>Output: <code>epicChargeSharing.root</code></p>"},{"location":"#requirements","title":"Requirements","text":"Dependency Version GEANT4 11.0+ ROOT 6.20+ CMake 3.9+ C++ C++20"},{"location":"#reconstruction-methods","title":"Reconstruction Methods","text":"Method Description Speed LogA Logarithmic attenuation model Slow LinA Linear attenuation model Slow DPC Discretized Positioning Circuit Fast <p>The charge fraction on pixel \\(i\\) follows:</p> \\[ F_i = \\frac{\\alpha_i / \\ln(d_i/d_0)}{\\sum_n \\alpha_n / \\ln(d_n/d_0)} \\]"},{"location":"#citation","title":"Citation","text":"<pre><code>@misc{bleher2025epicchargesharing,\n  author = {Tom Bleher and Igor Korover},\n  title = {epicChargeSharing: GEANT4 Simulation for AC-LGAD Charge Sharing},\n  year = {2025},\n  howpublished = {\\url{https://github.com/tom-bleher/epicChargeSharing}}\n}\n</code></pre> <p>Reference: M. Tornago et al., arXiv:2007.09528</p>"},{"location":"#contact","title":"Contact","text":"<ul> <li>Issues: GitHub Issues</li> <li>Email: tombleher@tauex.tau.ac.il</li> </ul>"},{"location":"FITTING_OPTIMIZATION_REPORT/","title":"Fitting Stage Performance Optimization Report","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#executive-summary","title":"Executive Summary","text":"<p>This report provides comprehensive optimization strategies for the Gaussian fitting stage in epicChargeSharing. The fitting macros (<code>FitGaussian1D.C</code>, <code>FitGaussian2D.C</code>) perform thousands of nonlinear least-squares fits using ROOT's Minuit2/Fumili2 minimizer with parallel execution via <code>TThreadExecutor</code>. This analysis covers minimizer selection, parallelization tuning, initial parameter estimation, memory management, and numerical stability.</p> <p>Key Findings: - Your code already uses Fumili2 (optimal for least-squares) with Migrad fallback - The parallel <code>TThreadExecutor::Foreach</code> pattern is well-implemented - Primary optimization opportunities: reduce per-fit allocations, improve initial parameter seeds, tune minimizer tolerances</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Current Architecture Analysis</li> <li>Minimizer Selection &amp; Configuration</li> <li>Parallelization Optimization</li> <li>Initial Parameter Estimation</li> <li>Memory &amp; Allocation Optimization</li> <li>Numerical Stability &amp; Convergence</li> <li>Error Model Performance</li> <li>Batch Processing Optimization</li> <li>Profiling &amp; Benchmarking</li> <li>Implementation Priority Matrix</li> </ol>"},{"location":"FITTING_OPTIMIZATION_REPORT/#1-current-architecture-analysis","title":"1. Current Architecture Analysis","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#11-fitting-pipeline-overview","title":"1.1 Fitting Pipeline Overview","text":"<p>Your fitting code follows this architecture:</p> <pre><code>ROOT File (TTree)\n    \u2502\n    \u251c\u2500\u2500 Sequential I/O: Preload all entries into vectors\n    \u2502\n    \u251c\u2500\u2500 Parallel Fitting: TThreadExecutor::Foreach\n    \u2502   \u251c\u2500\u2500 Per-event: Build TGraph/TGraph2D\n    \u2502   \u251c\u2500\u2500 Per-event: Configure ROOT::Fit::Fitter\n    \u2502   \u251c\u2500\u2500 Per-event: Run Fumili2 (fallback: Migrad)\n    \u2502   \u2514\u2500\u2500 Per-event: Extract results\n    \u2502\n    \u2514\u2500\u2500 Sequential Write: Fill output branches\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#12-current-strengths","title":"1.2 Current Strengths \u2713","text":"Aspect Implementation Status Minimizer Fumili2 (optimal for \u03c7\u00b2) \u2713 Good Fallback Migrad with relaxed tolerance \u2713 Good Parallelism <code>TThreadExecutor::Foreach</code> \u2713 Good I/O Strategy Preload inputs, batch write outputs \u2713 Good Branch selection <code>SetBranchStatus(\"*\", 0)</code> + selective enable \u2713 Good Error suppression <code>gErrorIgnoreLevel = kFatal</code> during fits \u2713 Good"},{"location":"FITTING_OPTIMIZATION_REPORT/#13-code-locations","title":"1.3 Code Locations","text":"File Lines Purpose <code>src/FitGaussian1D.C</code> ~1100 1D Gaussian fits (row/column/diagonal) <code>src/FitGaussian2D.C</code> ~800 2D Gaussian fits (full neighborhood) <code>src/ChargeUtils.h</code> ~415 Uncertainty model functions <code>farm/run_gaussian_fits.py</code> ~210 Batch runner for multiple files"},{"location":"FITTING_OPTIMIZATION_REPORT/#2-minimizer-selection-configuration","title":"2. Minimizer Selection &amp; Configuration","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#21-current-configuration","title":"2.1 Current Configuration","text":"<pre><code>// FitGaussian1D.C:571-575\nROOT::Math::MinimizerOptions::SetDefaultMinimizer(\"Minuit2\", \"Fumili2\");\nROOT::Math::MinimizerOptions::SetDefaultTolerance(1e-4);\nROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(250);\nROOT::Math::MinimizerOptions::SetDefaultStrategy(0);\nROOT::Math::MinimizerOptions::SetDefaultPrintLevel(0);\n</code></pre> <p>This is already well-tuned. Here's the rationale and potential adjustments:</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#22-minimizer-comparison","title":"2.2 Minimizer Comparison","text":"Algorithm Speed Robustness Best For Fumili2 \u2713 Fastest Medium Least-squares (your use case) Migrad Fast High General purpose, fallback Simplex Slow Highest Pathological cases GSLMultiFit Fast Medium Alternative to Fumili <p>Fumili2 is specialized for least-squares and likelihood minimization, making it 2-5x faster than Migrad for well-conditioned problems. Your fallback to Migrad when Fumili2 fails is the correct pattern.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#23-tolerance-tuning","title":"2.3 Tolerance Tuning","text":"<pre><code>// Current: 1e-4 (good balance)\n// For faster fits with slightly less precision:\nROOT::Math::MinimizerOptions::SetDefaultTolerance(1e-3);  // 2-3x faster\n\n// For high-precision physics results:\nROOT::Math::MinimizerOptions::SetDefaultTolerance(1e-6);  // 5-10x slower\n</code></pre> <p>Recommendation: Test with <code>1e-3</code> tolerance. If reconstruction resolution degrades by &lt;5%, keep it for significant speedup.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#24-strategy-options","title":"2.4 Strategy Options","text":"Strategy Description Speed 0 \u2713 Fast, fewer gradient calls Fastest 1 Standard, Hessian estimation Medium 2 Accurate, full Hessian Slowest <p>Your use of Strategy 0 is optimal for throughput-focused fitting.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#25-enable-openmp-for-gradient-calculations","title":"2.5 Enable OpenMP for Gradient Calculations","text":"<p>If ROOT was built with <code>minuit2_omp=ON</code>:</p> <pre><code>// Check if OpenMP acceleration is available\n#include &lt;Minuit2/MnConfig.h&gt;\n#ifdef MINOS_OMP\n    // Enable parallel gradient calculation\n    ROOT::Minuit2::MnGradientCalculator::SetParallelOMP(true);\n#endif\n</code></pre> <p>References: - ROOT Minuit2 Documentation - Minimizer Comparison - Mantid</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#3-parallelization-optimization","title":"3. Parallelization Optimization","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#31-current-implementation","title":"3.1 Current Implementation","text":"<pre><code>// FitGaussian2D.C:392-396\nROOT::TThreadExecutor exec;\nexec.Foreach([&amp;](int i){\n    // ... fit logic for event i\n}, indices);\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#32-thread-pool-size","title":"3.2 Thread Pool Size","text":"<p><code>TThreadExecutor</code> uses all available cores by default. For CPU-bound fitting:</p> <pre><code>// Explicit thread count (optional)\nunsigned int nThreads = std::thread::hardware_concurrency();\n// Leave 1 core for OS/I/O\nnThreads = std::max(1u, nThreads - 1);\nROOT::TThreadExecutor exec(nThreads);\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#33-chunking-for-better-load-balancing","title":"3.3 Chunking for Better Load Balancing","text":"<p>For workloads with variable fit complexity, explicit chunking helps:</p> <pre><code>// Instead of indices vector, use chunked processing\nconst size_t chunkSize = std::max&lt;size_t&gt;(100, nEntries / (4 * nThreads));\nexec.Foreach([&amp;](int i){ /* ... */ }, indices, chunkSize);\n</code></pre> <p>The third parameter to <code>Foreach</code> specifies chunk size. Larger chunks reduce overhead; smaller chunks improve load balance.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#34-avoid-thread-local-tf1-creation","title":"3.4 Avoid Thread-Local TF1 Creation \u26a0\ufe0f","text":"<p>Current issue in <code>RunGaussianFit</code> (FitGaussian1D.C:474):</p> <pre><code>// SLOW: Creates new TF1 every fit\nTF1 fLoc(\"fGauss1D_helper\", GaussPlusB, -1e9, 1e9, 4);\n</code></pre> <p>TF1 construction involves memory allocation and ROOT registration. Better approach:</p> <pre><code>// Use thread_local to reuse TF1 across fits within same thread\nstatic thread_local TF1* fLoc = nullptr;\nif (!fLoc) {\n    fLoc = new TF1(\"fGauss1D_helper\", GaussPlusB, -1e9, 1e9, 4);\n}\nfLoc-&gt;SetRange(rangeLo, rangeHi);\nfLoc-&gt;SetParameters(cfg.seedA, cfg.seedMu, cfg.seedSigma, cfg.seedB);\n// ... use fLoc\n</code></pre> <p>Expected improvement: 10-20% reduction in per-fit overhead.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#35-thread-local-bindata-reuse","title":"3.5 Thread-Local BinData Reuse","text":"<p>Similarly, <code>ROOT::Fit::BinData</code> can be reused:</p> <pre><code>// Current: Creates new BinData every fit\nROOT::Fit::BinData data(static_cast&lt;int&gt;(positions.size()), 1);\n\n// Better: Reuse with resize\nstatic thread_local ROOT::Fit::BinData* data = nullptr;\nif (!data) {\n    data = new ROOT::Fit::BinData();\n}\ndata-&gt;Initialize(positions.size(), 1, ROOT::Fit::BinData::kValueError);\n</code></pre> <p>References: - ROOT TThreadExecutor - A Parallelised ROOT for HEP</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#4-initial-parameter-estimation","title":"4. Initial Parameter Estimation","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#41-current-seed-calculation","title":"4.1 Current Seed Calculation","text":"<p>Your code uses moment-based seeding (<code>SeedSigma</code>, <code>WeightedCentroid</code>), which is good. Key functions:</p> <pre><code>// FitGaussian1D.C:405-438\ninline double SeedSigma(const std::vector&lt;double&gt;&amp; positions,\n                        const std::vector&lt;double&gt;&amp; charges,\n                        double baseline, ...) {\n    // Weighted variance calculation\n}\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#42-impact-of-good-initial-guesses","title":"4.2 Impact of Good Initial Guesses","text":"Seed Quality Fumili2 Iterations Migrad Iterations Excellent 3-5 10-15 Good \u2713 5-10 15-30 Poor 20-50+ 50-100+ (may fail) <p>Your moment-based seeding typically provides \"Good\" seeds. For \"Excellent\" seeds:</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#43-two-step-fast-gaussian-fit-fgf","title":"4.3 Two-Step Fast Gaussian Fit (FGF)","text":"<p>Research shows a two-step approach can be faster while maintaining accuracy:</p> <pre><code>// Step 1: Quick closed-form estimate (no iteration)\nauto [muEst, sigmaEst] = ClosedFormGaussianEstimate(positions, charges);\n\n// Step 2: Use as seed for refinement (fewer iterations needed)\ncfg.seedMu = muEst;\ncfg.seedSigma = sigmaEst;\n</code></pre> <p>The closed-form estimate uses: <pre><code>// Caruana's algorithm (linearized Gaussian)\n// ln(y) = ln(A) - (x - mu)^2 / (2*sigma^2)\n// Becomes: ln(y) = a + b*x + c*x^2  (linear regression)\ndouble ClosedFormGaussianMu(const std::vector&lt;double&gt;&amp; x,\n                            const std::vector&lt;double&gt;&amp; y) {\n    // Fit parabola to log(y) vs x\n    // mu = -b / (2c), sigma^2 = -1 / (2c)\n}\n</code></pre></p> <p>This can reduce total iterations by 30-50% for well-behaved data.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#44-adaptive-initial-sigma","title":"4.4 Adaptive Initial Sigma","text":"<p>Your code bounds sigma to <code>[sigLoBound, sigHiBound]</code>. Consider adaptive bounds based on data spread:</p> <pre><code>// Current: Fixed bounds\nconst double sigLoBound = pixelSize;\nconst double sigHiBound = neighborhoodRadius * pixelSpacing;\n\n// Better: Adaptive based on data\nauto [minPos, maxPos] = std::minmax_element(positions.begin(), positions.end());\nconst double dataSpread = *maxPos - *minPos;\nconst double sigHiBoundAdaptive = std::min(sigHiBound, 0.5 * dataSpread);\n</code></pre> <p>References: - Fast Gaussian Fitting - IEEE - Star Centroiding Algorithms - MDPI - Guo's Simple Algorithm</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#5-memory-allocation-optimization","title":"5. Memory &amp; Allocation Optimization","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#51-pre-allocated-work-buffers","title":"5.1 Pre-allocated Work Buffers","text":"<p>Your <code>FitWorkBuffers</code> structure is a good pattern. Ensure it's reused:</p> <pre><code>// FitGaussian1D.C:235-288\nstruct FitWorkBuffers {\n    std::vector&lt;double&gt; x_row;\n    std::vector&lt;double&gt; q_row;\n    // ...\n};\n</code></pre> <p>Recommendation: Use <code>thread_local</code> for the buffers:</p> <pre><code>static thread_local FitWorkBuffers workBuf;\nworkBuf.PrepareRowCol(N, needErrors);\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#52-flatvectorstore-optimization","title":"5.2 FlatVectorStore Optimization","text":"<p>Your <code>FlatVectorStore</code> class is efficient for preloading. Ensure reserve is called once:</p> <pre><code>// In FlatVectorStore::Initialize\nvoid Initialize(size_t nEntries, size_t reservePerEntry = 0) {\n    offsets.assign(nEntries, -1);\n    sizes.assign(nEntries, 0);\n    values.clear();\n    if (reservePerEntry &gt; 0) {\n        values.reserve(nEntries * reservePerEntry);  // Single allocation\n    }\n}\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#53-avoid-stdvector-copies","title":"5.3 Avoid std::vector Copies","text":"<p>In the parallel loop, you copy vectors from the preloaded store:</p> <pre><code>// Current: Implicit copy\nconst auto &amp;QLoc = v_Q[i];  // Reference - good!\n</code></pre> <p>This is already correct. Ensure all vector accesses use const references.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#54-output-buffer-allocation","title":"5.4 Output Buffer Allocation","text":"<p>Output buffers are pre-sized correctly:</p> <pre><code>std::vector&lt;double&gt; out_x_rec(nEntries, INVALID_VALUE);\n</code></pre> <p>No change needed.</p> <p>References: - ROOT BinData Memory</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#6-numerical-stability-convergence","title":"6. Numerical Stability &amp; Convergence","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#61-parameter-scaling","title":"6.1 Parameter Scaling","text":"<p>Your code sets step sizes based on parameter magnitudes:</p> <pre><code>// FitGaussian1D.C:511-516\nconst double stepA = std::max(1e-18, 0.01 * cfg.seedA);\nfitter.Config().ParSettings(0).SetStepSize(stepA);\nfitter.Config().ParSettings(1).SetStepSize(1e-4 * cfg.pixelSpacing);\n</code></pre> <p>This is good practice. For problems with disparate parameter scales, consider:</p> <pre><code>// Normalize parameters internally\n// Instead of fitting A, mu, sigma, B with different scales,\n// fit A/Amax, mu/pixelSpacing, sigma/pixelSpacing, B/Bmax\n// Then denormalize results\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#62-bound-configuration","title":"6.2 Bound Configuration","text":"<p>Your bounds are well-configured:</p> <pre><code>fitter.Config().ParSettings(0).SetLimits(1e-18, amplitudeMax);  // A &gt; 0\nfitter.Config().ParSettings(1).SetLimits(cfg.muLo, cfg.muHi);   // mu in pixel\nfitter.Config().ParSettings(3).SetLimits(-baselineMax, baselineMax);  // B can be negative\n</code></pre> <p>Tip: Very tight bounds can slow convergence. If mu is always well-seeded, consider:</p> <pre><code>// Looser bounds for faster convergence\nconst double muMargin = 0.1 * pixelSpacing;  // 10% margin\nfitter.Config().ParSettings(1).SetLimits(cfg.muLo - muMargin, cfg.muHi + muMargin);\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#63-handling-fit-failures-gracefully","title":"6.3 Handling Fit Failures Gracefully","text":"<p>Your fallback pattern is correct:</p> <pre><code>bool ok = fitter.Fit(data);\nif (!ok) {\n    fitter.Config().SetMinimizer(\"Minuit2\", \"Migrad\");\n    fitter.Config().MinimizerOptions().SetStrategy(1);\n    ok = fitter.Fit(data);\n}\n</code></pre> <p>Enhancement: Track failure rates for diagnostics:</p> <pre><code>static thread_local struct {\n    std::atomic&lt;int&gt; fumiliSuccess{0};\n    std::atomic&lt;int&gt; fumiliFail{0};\n    std::atomic&lt;int&gt; migradSuccess{0};\n    std::atomic&lt;int&gt; migradFail{0};\n} fitStats;\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#64-early-exit-for-trivial-cases","title":"6.4 Early Exit for Trivial Cases","text":"<p>Your code handles low-contrast cases:</p> <pre><code>// FitGaussian2D.C:524-554\nif (A0 &lt; 1e-6) {\n    // Use centroid instead of fitting\n    out_x_rec[i] = xw / wsum;\n    out_y_rec[i] = yw / wsum;\n    return;\n}\n</code></pre> <p>This is efficient. Consider also skipping fits for: - Very few data points (already handled: <code>if (g2d.GetN() &lt; 5) return;</code>) - All-zero or constant charge distributions</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#7-error-model-performance","title":"7. Error Model Performance","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#71-current-uncertainty-models","title":"7.1 Current Uncertainty Models","text":"<p>Your <code>ChargeUtils.h</code> provides multiple error models:</p> Model Function Complexity UniformPercentOfMax Simple multiplication O(1) QnQiScaled Division + multiplication O(1) DistancePowerSigma <code>std::pow</code>, bounds check O(1) but heavier DistancePowerSigmaInverse Same O(1)"},{"location":"FITTING_OPTIMIZATION_REPORT/#72-optimize-stdpow-calls","title":"7.2 Optimize <code>std::pow</code> Calls","text":"<p><code>std::pow</code> is expensive (~50-100 cycles). For integer or common exponents:</p> <pre><code>// Current: Generic pow\nconst double baseSigma = sigma_min * std::pow(1.0 + ratio, exponent);\n\n// Faster for common cases:\ninline double FastPow(double base, double exp) {\n    if (exp == 1.0) return base;\n    if (exp == 1.5) return base * std::sqrt(base);\n    if (exp == 2.0) return base * base;\n    return std::pow(base, exp);  // Fallback\n}\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#73-precompute-distance-errors","title":"7.3 Precompute Distance Errors","text":"<p>For distance-weighted errors, compute all sigmas upfront:</p> <pre><code>// Instead of computing in the Add() loop:\nstd::vector&lt;double&gt; sigmaVals(nPts);\nfor (int k = 0; k &lt; nPts; ++k) {\n    sigmaVals[k] = distanceSigma(distances[k], qmax);\n}\n\n// Then use cached values:\nfor (int k = 0; k &lt; nPts; ++k) {\n    data.Add(xy, Zf[k], sigmaVals[k]);\n}\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#8-batch-processing-optimization","title":"8. Batch Processing Optimization","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#81-current-batch-runner","title":"8.1 Current Batch Runner","text":"<p><code>farm/run_gaussian_fits.py</code> runs fits sequentially per file:</p> <pre><code>for root_file in root_files:\n    subprocess.run([root_executable, \"-l\", \"-b\", \"-q\", macro_call], check=True)\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#82-multi-process-parallelization","title":"8.2 Multi-Process Parallelization","text":"<p>For multiple files, run fits in parallel:</p> <pre><code>from concurrent.futures import ProcessPoolExecutor\n\ndef run_single_file(root_file):\n    # ... subprocess.run(...)\n\nwith ProcessPoolExecutor(max_workers=4) as executor:\n    executor.map(run_single_file, root_files)\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#83-alternative-single-invocation-for-multiple-files","title":"8.3 Alternative: Single Invocation for Multiple Files","text":"<p>Modify <code>FitGaussian1D.C</code> to accept a list of files:</p> <pre><code>int FitGaussian1D_Batch(const std::vector&lt;std::string&gt;&amp; filenames, ...) {\n    for (const auto&amp; filename : filenames) {\n        FitGaussian1D(filename.c_str(), ...);\n    }\n    return 0;\n}\n</code></pre> <p>This avoids ROOT startup overhead per file.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#84-hadd-then-fit-strategy","title":"8.4 hadd-then-fit Strategy","text":"<p>For many small files, merge first:</p> <pre><code># Merge all ROOT files\nhadd -f merged.root input_*.root\n\n# Run fitting once on merged file\nroot -l -b -q 'FitGaussian1D.C(\"merged.root\")'\n</code></pre> <p>This reduces I/O overhead and improves parallelization efficiency.</p> <p>References: - ROOT Forum - Fitting in Parallel</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#9-profiling-benchmarking","title":"9. Profiling &amp; Benchmarking","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#91-built-in-timing","title":"9.1 Built-in Timing","text":"<p>Add timing instrumentation:</p> <pre><code>#include &lt;chrono&gt;\n\nint FitGaussian1D(...) {\n    auto startTotal = std::chrono::high_resolution_clock::now();\n\n    // ... existing code ...\n\n    // Before parallel loop\n    auto startFitting = std::chrono::high_resolution_clock::now();\n    exec.Foreach([&amp;](int i){ /* ... */ }, indices);\n    auto endFitting = std::chrono::high_resolution_clock::now();\n\n    // ... write results ...\n\n    auto endTotal = std::chrono::high_resolution_clock::now();\n\n    double fittingMs = std::chrono::duration&lt;double, std::milli&gt;(endFitting - startFitting).count();\n    double totalMs = std::chrono::duration&lt;double, std::milli&gt;(endTotal - startTotal).count();\n\n    ::Info(\"FitGaussian1D\",\n           \"Performance: %.1f ms total, %.1f ms fitting (%.1f%%), %.2f events/sec\",\n           totalMs, fittingMs, 100.0 * fittingMs / totalMs,\n           1000.0 * nEntries / totalMs);\n}\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#92-per-fit-timing-debug","title":"9.2 Per-Fit Timing (Debug)","text":"<p>For detailed analysis:</p> <pre><code>// In parallel loop\nthread_local std::vector&lt;double&gt; fitTimes;\nauto fitStart = std::chrono::high_resolution_clock::now();\nbool ok = fitter.Fit(data);\nauto fitEnd = std::chrono::high_resolution_clock::now();\nfitTimes.push_back(std::chrono::duration&lt;double, std::micro&gt;(fitEnd - fitStart).count());\n</code></pre>"},{"location":"FITTING_OPTIMIZATION_REPORT/#93-profile-with-perf","title":"9.3 Profile with perf","text":"<pre><code># Profile the fitting macro\nperf record -g root -l -b -q 'FitGaussian1D.C(\"input.root\")'\nperf report --hierarchy\n</code></pre> <p>Look for hotspots in: - <code>Minuit2::*</code> - Minimizer overhead - <code>TF1::*</code> - Function evaluation - <code>std::vector::*</code> - Memory allocation</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#94-expected-time-breakdown","title":"9.4 Expected Time Breakdown","text":"<p>For a well-optimized fit:</p> Phase Expected % I/O (read) 5-15% Fit setup (TF1, BinData) 10-20% Minimization 50-70% I/O (write) 5-15% <p>If setup time is &gt;30%, focus on object reuse.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#10-implementation-priority-matrix","title":"10. Implementation Priority Matrix","text":"Optimization Impact Effort Priority Thread-local TF1/BinData reuse High Low P0 Tolerance tuning (1e-3) Medium Low P0 Closed-form Gaussian seed Medium Medium P1 Precompute distance errors Low-Medium Low P1 FastPow for common exponents Low Low P2 Multi-file parallel processing Medium Low P2 Parameter normalization Low Medium P3 OpenMP gradient (if available) Medium Low P3"},{"location":"FITTING_OPTIMIZATION_REPORT/#quick-wins-implement-today","title":"Quick Wins (Implement Today)","text":"<ol> <li>Thread-local TF1 and BinData - Avoid per-fit allocations</li> <li>Test tolerance=1e-3 - Measure impact on reconstruction quality</li> <li>Add timing instrumentation - Identify actual bottlenecks</li> </ol>"},{"location":"FITTING_OPTIMIZATION_REPORT/#medium-term-this-week","title":"Medium-Term (This Week)","text":"<ol> <li>Implement closed-form Gaussian seed - Reduce iteration count</li> <li>Cache distance error values - Avoid redundant <code>std::pow</code> calls</li> <li>Batch file processing - Parallelize across files</li> </ol>"},{"location":"FITTING_OPTIMIZATION_REPORT/#long-term-future","title":"Long-Term (Future)","text":"<ol> <li>Consider GSLMultiFit as alternative to Fumili2 (benchmark)</li> <li>Evaluate custom Levenberg-Marquardt for specific Gaussian form</li> <li>GPU fitting for massive datasets (CUDA-based minimizers)</li> </ol>"},{"location":"FITTING_OPTIMIZATION_REPORT/#summary","title":"Summary","text":"<p>Your fitting code is already well-architected with: - Correct minimizer choice (Fumili2 with Migrad fallback) - Good parallelization pattern (TThreadExecutor) - Efficient I/O (branch selection, preloading)</p> <p>The highest-impact improvements are:</p> Change Expected Improvement Effort Thread-local TF1/BinData 10-20% faster 1 hour Tolerance 1e-3 2-3x faster per fit 5 minutes Closed-form seed 30-50% fewer iterations 2 hours <p>Recommended first step: Add timing instrumentation to measure where time is actually spent, then target the dominant phase.</p>"},{"location":"FITTING_OPTIMIZATION_REPORT/#references","title":"References","text":""},{"location":"FITTING_OPTIMIZATION_REPORT/#root-fitting","title":"ROOT Fitting","text":"<ul> <li>ROOT Fitting Histograms Guide</li> <li>ROOT Minuit2 Documentation</li> <li>ROOT::Fit::BinData</li> <li>ROOT::Fit::Fitter</li> </ul>"},{"location":"FITTING_OPTIMIZATION_REPORT/#minimization-algorithms","title":"Minimization Algorithms","text":"<ul> <li>Levenberg-Marquardt vs Gauss-Newton</li> <li>Minimizer Comparison - Mantid</li> <li>GSL Nonlinear Least-Squares</li> </ul>"},{"location":"FITTING_OPTIMIZATION_REPORT/#fast-gaussian-fitting","title":"Fast Gaussian Fitting","text":"<ul> <li>Fast, Accurate, Separable Gaussian Fitting</li> <li>Star Centroiding Algorithms - IEEE</li> <li>Guo's Simple Algorithm</li> <li>Gaussian Curve Fitting - Stack Overflow</li> </ul>"},{"location":"FITTING_OPTIMIZATION_REPORT/#root-parallelization","title":"ROOT Parallelization","text":"<ul> <li>TThreadExecutor - OSTI</li> <li>Parallelised ROOT for HEP</li> <li>ROOT Forum - Parallel Fitting</li> </ul>"},{"location":"FITTING_OPTIMIZATION_REPORT/#numerical-optimization","title":"Numerical Optimization","text":"<ul> <li>Nonlinear Least-Squares Preconditioning</li> <li>SciPy least_squares</li> <li>Ceres Solver</li> </ul> <p>Report generated: December 2025 Based on: ROOT 6.x, Minuit2, C++20 Codebase analyzed: epicChargeSharing Gaussian fitting macros</p>"},{"location":"METADATA_ANALYSIS_REPORT/","title":"Metadata Storage Analysis Report","text":""},{"location":"METADATA_ANALYSIS_REPORT/#executive-summary","title":"Executive Summary","text":"<p>This report analyzes the current metadata storage implementation in the epicChargeSharing simulation, detailing what is saved, how it's saved, and provides recommendations for improvement.</p>"},{"location":"METADATA_ANALYSIS_REPORT/#1-current-implementation","title":"1. Current Implementation","text":""},{"location":"METADATA_ANALYSIS_REPORT/#11-architecture-overview","title":"1.1 Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         RunAction                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502              BuildMetadataPublisher()                        \u2502\u2502\n\u2502  \u2502  Collects runtime values from member variables:              \u2502\u2502\n\u2502  \u2502  - fGridPixelSize, fGridPixelSpacing, ...                   \u2502\u2502\n\u2502  \u2502  - fPosReconModel, fDenominatorMode, ...                    \u2502\u2502\n\u2502  \u2502  - Constants::D0, Constants::GAIN, ...                      \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    MetadataPublisher                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502 Struct Categories:                                           \u2502\u2502\n\u2502  \u2502  \u2022 GridMetadata      (8 fields)                             \u2502\u2502\n\u2502  \u2502  \u2022 ModelMetadata     (5 fields)                             \u2502\u2502\n\u2502  \u2502  \u2022 PhysicsMetadata   (4 fields)                             \u2502\u2502\n\u2502  \u2502  \u2022 NoiseMetadata     (3 fields)                             \u2502\u2502\n\u2502  \u2502  \u2022 PostProcessMetadata (2 fields)                           \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502                         \u2502                                        \u2502\n\u2502  CollectEntries() \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u25ba EntryList (vector&lt;pair&lt;str,str&gt;&gt;) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    WriteEntriesUnlocked()                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502 for (key, value) in entries:                                 \u2502\u2502\n\u2502  \u2502     TNamed meta(key, value);                                 \u2502\u2502\n\u2502  \u2502     meta.Write(\"\", TObject::kOverwrite);                     \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#12-storage-method","title":"1.2 Storage Method","text":"<p>Current approach: <code>TNamed</code> objects stored at ROOT file root level</p> <pre><code>// RootIO.cc:467-479\nvoid MetadataPublisher::WriteEntriesUnlocked(TFile* file, const EntryList&amp; entries) {\n    file-&gt;cd();\n    for (const auto&amp; [key, value] : entries) {\n        TNamed meta(key.c_str(), value.c_str());\n        meta.Write(\"\", TObject::kOverwrite);\n    }\n    file-&gt;Flush();\n}\n</code></pre> <p>Characteristics: - All values stored as strings (no type preservation) - Objects scattered at file root (not organized in directory or attached to TTree) - Overwrites existing entries with same key</p>"},{"location":"METADATA_ANALYSIS_REPORT/#13-when-metadata-is-written","title":"1.3 When Metadata is Written","text":"Scenario When Written Location Single-threaded End of run <code>HandleWorkerEndOfRun()</code> line 448 Multi-threaded After merge <code>MergeWorkerFilesAndPublishMetadata()</code> line 575-577"},{"location":"METADATA_ANALYSIS_REPORT/#2-what-is-currently-saved","title":"2. What Is Currently Saved","text":""},{"location":"METADATA_ANALYSIS_REPORT/#21-complete-metadata-field-inventory","title":"2.1 Complete Metadata Field Inventory","text":"Category Field Type Source Description Schema <code>MetadataSchemaVersion</code> String Hardcoded \"2\" Version for backward compatibility Grid Geometry <code>GridPixelSize_mm</code> Double <code>fGridPixelSize</code> Physical pixel size <code>GridPixelSpacing_mm</code> Double <code>fGridPixelSpacing</code> Pixel pitch <code>GridPixelCornerOffset_mm</code> Double <code>fGridPixelCornerOffset</code> Edge offset <code>GridDetectorSize_mm</code> Double <code>fGridDetSize</code> Total detector size <code>GridNumBlocksPerSide</code> Int <code>fGridNumBlocksPerSide</code> Pixels per side <code>FullGridSide</code> Int <code>fFullGridSide</code> Full grid dimension <code>NeighborhoodRadius</code> Int <code>fGridNeighborhoodRadius</code> Neighborhood size Charge Sharing Model <code>ChargeSharingModel</code> String <code>fPosReconModel</code> LogA, LinA, or DPC <code>DenominatorMode</code> String <code>fDenominatorMode</code> Neighborhood, RowCol, ChargeBlock <code>ChargeSharingLinearBeta_per_um</code> Double <code>fChargeSharingBeta</code> \u03b2 for LinA/DPC (conditional) <code>ChargeSharingPitch_mm</code> Double <code>fChargeSharingPitch</code> Pitch for model Physics Constants <code>ChargeSharingReferenceD0_microns</code> Double <code>Constants::D0</code> d\u2080 = 1 \u00b5m (Tornago Eq.4) <code>IonizationEnergy_eV</code> Double <code>Constants::IONIZATION_ENERGY</code> 3.6 eV/pair <code>Gain</code> Double <code>Constants::GAIN</code> AC-LGAD gain (20) <code>ElementaryCharge_C</code> Double <code>Constants::ELEMENTARY_CHARGE</code> 1.602e-19 C Noise Model <code>NoisePixelGainSigmaMin</code> Double <code>Constants::PIXEL_GAIN_SIGMA_MIN</code> Min gain variation <code>NoisePixelGainSigmaMax</code> Double <code>Constants::PIXEL_GAIN_SIGMA_MAX</code> Max gain variation <code>NoiseElectronCount</code> Double <code>Constants::NOISE_ELECTRON_COUNT</code> Additive noise (500 e\u207b) Flags <code>ChargeSharingEmitDistanceAlpha</code> Bool <code>fEmitDistanceAlphaMeta</code> d_i/\u03b1_i stored? <code>ChargeSharingFullFractionsEnabled</code> Bool <code>fStoreFullFractions</code> Full grid stored? <code>PostProcessFitGaus1DEnabled</code> Bool <code>Constants::FIT_GAUS_1D</code> 1D fit enabled? <code>PostProcessFitGaus2DEnabled</code> Bool <code>Constants::FIT_GAUS_2D</code> 2D fit enabled?"},{"location":"METADATA_ANALYSIS_REPORT/#22-what-is-not-saved-missing-metadata","title":"2.2 What Is NOT Saved (Missing Metadata)","text":"Missing Field Importance Recommendation Simulation Version High Add git commit hash or version string Geant4 Version High Add <code>G4VERSION_NUMBER</code> ROOT Version Medium Add <code>ROOT_VERSION_CODE</code> Run Timestamp High Add ISO 8601 datetime Number of Events High Add actual event count Random Seed High Critical for reproducibility Primary Particle Medium Type, energy, position config Detector Material Medium Silicon properties used CPU/Thread Info Low Number of threads, host info"},{"location":"METADATA_ANALYSIS_REPORT/#3-analysis-of-current-approach","title":"3. Analysis of Current Approach","text":""},{"location":"METADATA_ANALYSIS_REPORT/#31-strengths","title":"3.1 Strengths","text":"Aspect Assessment Simplicity Easy to implement and understand Portability TNamed is universally supported in ROOT Schema versioning Allows for future format changes Thread safety Mutex-protected writes Categorization Code-side structs organize parameters logically"},{"location":"METADATA_ANALYSIS_REPORT/#32-weaknesses","title":"3.2 Weaknesses","text":"Issue Impact Severity No type preservation All values stored as strings, require parsing Medium Flat organization All objects at file root, cluttered namespace Low Not attached to TTree Metadata separate from data it describes Medium Conditional writes Some fields only written if non-zero/valid Low Missing critical fields No version, timestamp, seed, event count High No validation No schema enforcement on read Low"},{"location":"METADATA_ANALYSIS_REPORT/#4-recommendations-for-improvement","title":"4. Recommendations for Improvement","text":""},{"location":"METADATA_ANALYSIS_REPORT/#41-immediate-improvements-low-effort","title":"4.1 Immediate Improvements (Low Effort)","text":""},{"location":"METADATA_ANALYSIS_REPORT/#a-add-missing-critical-metadata","title":"A. Add Missing Critical Metadata","text":"<pre><code>// Add to CollectEntries() in RootIO.cc\n\n// Version information\nadd(\"SimulationVersion\", PROJECT_VERSION);  // From CMake\nadd(\"Geant4Version\", std::to_string(G4VERSION_NUMBER));\nadd(\"ROOTVersion\", std::to_string(ROOT_VERSION_CODE));\n\n// Run information\nadd(\"RunTimestamp\", GetISOTimestamp());  // New helper function\naddInt(\"TotalEvents\", fTotalEvents);     // Track in RunAction\nadd(\"RandomSeed\", std::to_string(CLHEP::HepRandom::getTheSeed()));\n\n// Primary particle config\nadd(\"PrimaryParticle\", \"proton\");  // Or from config\naddDouble(\"PrimaryEnergy_MeV\", fPrimaryEnergy);\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#b-add-timestamp-helper","title":"B. Add Timestamp Helper","text":"<pre><code>// In RootIO.cc\nstd::string GetISOTimestamp() {\n    auto now = std::chrono::system_clock::now();\n    auto time = std::chrono::system_clock::to_time_t(now);\n    std::stringstream ss;\n    ss &lt;&lt; std::put_time(std::gmtime(&amp;time), \"%Y-%m-%dT%H:%M:%SZ\");\n    return ss.str();\n}\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#42-medium-term-improvements","title":"4.2 Medium-Term Improvements","text":""},{"location":"METADATA_ANALYSIS_REPORT/#a-use-tparameter-for-typed-values","title":"A. Use TParameter for Typed Values","text":"<pre><code>// Instead of TNamed for all values, use typed parameters:\ntemplate&lt;typename T&gt;\nvoid WriteTypedParameter(TFile* file, const std::string&amp; name, T value) {\n    file-&gt;cd();\n    TParameter&lt;T&gt; param(name.c_str(), value);\n    param.Write(\"\", TObject::kOverwrite);\n}\n\n// Usage:\nWriteTypedParameter&lt;Double_t&gt;(file, \"Gain\", 20.0);\nWriteTypedParameter&lt;Int_t&gt;(file, \"GridNumBlocksPerSide\", 59);\nWriteTypedParameter&lt;Bool_t&gt;(file, \"FullFractionsEnabled\", true);\n</code></pre> <p>Benefits: - Type preserved in ROOT file - No string parsing needed on read - Native support for TBrowser inspection</p>"},{"location":"METADATA_ANALYSIS_REPORT/#b-attach-metadata-to-ttree-via-userinfo","title":"B. Attach Metadata to TTree via UserInfo","text":"<pre><code>// In InitializeRootOutputs() after creating tree:\nvoid AttachMetadataToTree(TTree* tree) {\n    TList* userInfo = tree-&gt;GetUserInfo();\n\n    // Add typed parameters\n    userInfo-&gt;Add(new TParameter&lt;Double_t&gt;(\"Gain\", Constants::GAIN));\n    userInfo-&gt;Add(new TParameter&lt;Int_t&gt;(\"NeighborhoodRadius\", fNeighborhoodRadius));\n\n    // Add strings\n    userInfo-&gt;Add(new TNamed(\"ChargeSharingModel\", \"DPC\"));\n    userInfo-&gt;Add(new TNamed(\"DenominatorMode\", \"Neighborhood\"));\n}\n\n// Reading:\nTTree* tree = (TTree*)file-&gt;Get(\"Hits\");\nTList* info = tree-&gt;GetUserInfo();\nauto* gain = (TParameter&lt;Double_t&gt;*)info-&gt;FindObject(\"Gain\");\ndouble gainValue = gain-&gt;GetVal();\n</code></pre> <p>Benefits: - Metadata travels with the TTree - Clear association between data and its description - Standard HEP practice (used by ATLAS, CMS, LHCb)</p>"},{"location":"METADATA_ANALYSIS_REPORT/#43-long-term-improvements","title":"4.3 Long-Term Improvements","text":""},{"location":"METADATA_ANALYSIS_REPORT/#a-create-dedicated-metadata-ttree","title":"A. Create Dedicated Metadata TTree","text":"<pre><code>// Separate metadata tree for complex/variable-length info\nTTree* metaTree = new TTree(\"Metadata\", \"Simulation Configuration\");\n\n// Store as single entry with branches\nstruct SimConfig {\n    char model[32];\n    double gain;\n    int numPixels;\n    // ...\n};\nSimConfig config;\nmetaTree-&gt;Branch(\"config\", &amp;config, \"model[32]/C:gain/D:numPixels/I\");\nmetaTree-&gt;Fill();  // Single entry\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#b-use-jsonxml-sidecar","title":"B. Use JSON/XML Sidecar","text":"<p>For complex nested configuration, consider writing a JSON sidecar file:</p> <pre><code>{\n  \"schema_version\": \"3.0\",\n  \"simulation\": {\n    \"version\": \"1.2.0\",\n    \"git_commit\": \"abc123\",\n    \"timestamp\": \"2025-12-05T10:30:00Z\"\n  },\n  \"detector\": {\n    \"size_mm\": 30.0,\n    \"pixel\": {\n      \"size_mm\": 0.1,\n      \"pitch_mm\": 0.5\n    }\n  },\n  \"physics\": {\n    \"model\": \"DPC\",\n    \"denominator_mode\": \"Neighborhood\"\n  }\n}\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#5-implementation-priority","title":"5. Implementation Priority","text":"Priority Improvement Effort Impact P0 Add timestamp, event count, random seed Low High P0 Add version strings (sim, G4, ROOT) Low High P1 Use TParameter for numeric values Medium Medium P1 Attach core metadata to TTree UserInfo Medium Medium P2 Add primary particle configuration Low Medium P3 Create metadata TTree for complex data High Low P3 JSON sidecar for full configuration dump Medium Low"},{"location":"METADATA_ANALYSIS_REPORT/#6-example-reading-current-metadata","title":"6. Example: Reading Current Metadata","text":"<pre><code>// C++ example\nTFile* f = TFile::Open(\"epicChargeSharing.root\");\n\n// List all metadata\nTIter next(f-&gt;GetListOfKeys());\nTKey* key;\nwhile ((key = (TKey*)next())) {\n    if (strcmp(key-&gt;GetClassName(), \"TNamed\") == 0) {\n        TNamed* meta = (TNamed*)key-&gt;ReadObj();\n        std::cout &lt;&lt; meta-&gt;GetName() &lt;&lt; \" = \" &lt;&lt; meta-&gt;GetTitle() &lt;&lt; std::endl;\n    }\n}\n\n// Read specific value\nTNamed* mode = (TNamed*)f-&gt;Get(\"DenominatorMode\");\nstd::string modeStr = mode ? mode-&gt;GetTitle() : \"unknown\";\n\n// Parse numeric value\nTNamed* gain = (TNamed*)f-&gt;Get(\"Gain\");\ndouble gainVal = gain ? std::stod(gain-&gt;GetTitle()) : 0.0;\n</code></pre> <pre><code># Python/uproot example\nimport uproot\n\nwith uproot.open(\"epicChargeSharing.root\") as f:\n    # TNamed objects appear as strings in classnames\n    for key in f.keys():\n        obj = f[key]\n        if hasattr(obj, 'title'):  # TNamed-like\n            print(f\"{key}: {obj.title}\")\n</code></pre>"},{"location":"METADATA_ANALYSIS_REPORT/#7-conclusion","title":"7. Conclusion","text":"<p>The current metadata implementation is functional but could be enhanced for:</p> <ol> <li>Reproducibility: Add version, timestamp, and random seed</li> <li>Type safety: Use TParameter for numeric values</li> <li>Organization: Attach metadata to TTree via UserInfo</li> <li>Completeness: Add missing physics configuration</li> </ol> <p>The recommended approach is to implement P0 improvements immediately, followed by P1 changes for better type handling and organization.</p>"},{"location":"METADATA_ANALYSIS_REPORT/#references","title":"References","text":"<ul> <li>ROOT TFile Documentation</li> <li>ROOT TTree Class Reference</li> <li>ROOT Forum: TNamed/TParameter Best Practices</li> <li>Scikit-HEP TTree Details</li> </ul>"},{"location":"NamingConventions/","title":"epicChargeSharing Naming Conventions Report","text":"<p>This document catalogs the naming conventions used throughout the codebase for functions, variables, classes, and other identifiers.</p>"},{"location":"NamingConventions/#namespaces","title":"Namespaces","text":"Namespace Purpose <code>ECS</code> Epic Charge Sharing - primary namespace for all simulation utilities <code>ECS::Config</code> Configuration structs and enums <code>ECS::Internal</code> Internal implementation details (backward compatibility) <code>Constants</code> Global simulation constants (backward compat wrapper around <code>ECS::Config</code>)"},{"location":"NamingConventions/#classes","title":"Classes","text":"Class File Purpose <code>ActionInitialization</code> ActionInitialization.hh Geant4 user action initialization <code>ChargeSharingCalculator</code> ChargeSharingCalculator.hh Core charge distribution algorithm (Tornago model) <code>DetectorConstruction</code> DetectorConstruction.hh Geant4 geometry definition for AC-LGAD <code>EventAction</code> EventAction.hh Per-event data collection and processing <code>PhysicsList</code> PhysicsList.hh Geant4 physics processes configuration <code>PrimaryGenerator</code> PrimaryGenerator.hh Particle gun configuration and vertex sampling <code>RunAction</code> RunAction.hh Per-run initialization, ROOT file management <code>SteppingAction</code> SteppingAction.hh Per-step energy deposition tracking <code>NeighborhoodLayout</code> NeighborhoodUtils.hh Grid layout manager for pixel neighborhoods <code>RootFileWriter</code> RootHelpers.hh Thread-safe ROOT file creation and management <code>WorkerSync</code> RootHelpers.hh Multithreaded worker synchronization <code>BranchConfigurator</code> RootIO.hh ROOT TTree branch setup <code>TreeFiller</code> RootIO.hh Event data serialization to ROOT trees <code>MetadataPublisher</code> RootIO.hh Simulation metadata writing <code>PostProcessingRunner</code> RootIO.hh Post-run ROOT macro execution"},{"location":"NamingConventions/#structs","title":"Structs","text":""},{"location":"NamingConventions/#configuration-structs-ecsconfig","title":"Configuration Structs (<code>ECS::Config</code>)","text":"Struct Purpose <code>DetectorGeometry</code> Physical dimensions: detector size, pixel size, spacing, thickness <code>PhysicsParameters</code> Charge sharing model parameters: diffusion sigma, gain layer position <code>NoiseModel</code> Electronic noise parameters for charge collection <code>ReconstructionConfig</code> Position reconstruction algorithm settings"},{"location":"NamingConventions/#data-structs","title":"Data Structs","text":"Struct Location Purpose <code>SamplingWindow</code> PrimaryGenerator.hh Safe vertex sampling bounds <code>GridGeometry</code> ChargeSharingCalculator.hh Pixel grid coordinate system <code>ChargeData</code> ChargeSharingCalculator.hh Per-pixel charge accumulation <code>EventSummaryData</code> RootIO.hh Aggregated event statistics <code>EventRecord</code> RootIO.hh Complete event data for ROOT output"},{"location":"NamingConventions/#enums","title":"Enums","text":""},{"location":"NamingConventions/#ecsconfigposreconmodel","title":"<code>ECS::Config::PosReconModel</code>","text":"<p>Position reconstruction algorithm selection: - <code>Log</code> - Logarithmic weighting - <code>Linear</code> - Linear interpolation - <code>DPC</code> - Discretized Positioning Circuit</p>"},{"location":"NamingConventions/#ecsconfigdenominatormode","title":"<code>ECS::Config::DenominatorMode</code>","text":"<p>Normalization mode for position reconstruction: - <code>Neighborhood</code> - Use full neighborhood sum - <code>ChargeBlock</code> - Use 2\u00d72 charge block - <code>RowCol</code> - Use row/column sums</p>"},{"location":"NamingConventions/#ecsconfigchargemode","title":"<code>ECS::Config::ChargeMode</code>","text":"<p>Charge source selection: - <code>Induced</code> - Induced charge on electrodes - <code>Collected</code> - Collected charge carriers</p>"},{"location":"NamingConventions/#member-variable-convention","title":"Member Variable Convention","text":"<p>Following Geant4 conventions, member variables use the <code>f</code> prefix:</p> Pattern Example Description <code>fVariableName</code> <code>fDetector</code> Pointer/reference to detector <code>fVariableName</code> <code>fPixelSize</code> Scalar value <code>fVariableName</code> <code>fChargeFractions</code> Container (vector/array)"},{"location":"NamingConventions/#key-member-variables-by-class","title":"Key Member Variables by Class","text":"<p>DetectorConstruction: - <code>fDetSize</code> - Detector size - <code>fPixelSize</code> - Individual pixel size - <code>fPixelSpacing</code> - Pixel pitch (center-to-center) - <code>fPixelCornerOffset</code> - Offset to first pixel corner - <code>fNeighborhoodRadius</code> - Neighborhood grid radius - <code>fDetectorThickness</code> - Silicon thickness</p> <p>ChargeSharingCalculator: - <code>fGridGeometry</code> - Grid coordinate system - <code>fChargeData</code> - Accumulated charge per pixel - <code>fDiffusionSigma</code> - Charge diffusion parameter - <code>fGainLayerZ</code> - Gain layer position</p> <p>EventAction: - <code>fTotalEnergyDeposit</code> - Cumulative energy deposition - <code>fPrimaryPosition</code> - Primary vertex coordinates - <code>fNeighborhoodChargeFractions</code> - Charge distribution array - <code>fReconstructedPosition</code> - Reconstructed hit position</p> <p>RunAction: - <code>fRootWriter</code> - ROOT file manager - <code>fWorkerSync</code> - Thread synchronization - <code>fOutputTree</code> - ROOT TTree pointer - <code>fBranchConfig</code> - Branch configuration</p> <p>PrimaryGenerator: - <code>fParticleGun</code> - Geant4 particle gun - <code>fUseFixedPosition</code> - Fixed vs random sampling flag - <code>fFixedX</code>, <code>fFixedY</code> - Fixed position coordinates - <code>fSamplingWindow</code> - Cached sampling bounds</p>"},{"location":"NamingConventions/#constants-constants-namespace","title":"Constants (<code>Constants::</code> namespace)","text":"Constant Value Description <code>DETECTOR_SIZE</code> 30.0 mm Total detector extent <code>PIXEL_SIZE</code> 450 \u00b5m Active pixel area <code>PIXEL_SPACING</code> 500 \u00b5m Pixel pitch <code>DETECTOR_THICKNESS</code> 50 \u00b5m Silicon thickness <code>DIFFUSION_SIGMA</code> 6.0 \u00b5m Charge spread parameter <code>GAIN_LAYER_Z</code> -25 \u00b5m Gain layer depth <code>NEIGHBORHOOD_RADIUS</code> 2 Grid half-width (5\u00d75 grid) <code>PRIMARY_PARTICLE_Z_POSITION</code> 5.0 mm Gun position above detector"},{"location":"NamingConventions/#root-branch-names","title":"ROOT Branch Names","text":"<p>Output tree branches follow snake_case convention:</p> Branch Type Description <code>event_id</code> Int_t Event number <code>primary_x</code>, <code>primary_y</code> Double_t True vertex position <code>reco_x</code>, <code>reco_y</code> Double_t Reconstructed position <code>total_energy</code> Double_t Total energy deposit <code>charge_fractions</code> vector Neighborhood charge array <code>center_pixel_charge</code> Double_t Central pixel charge <code>neighborhood_sum</code> Double_t Total neighborhood charge"},{"location":"NamingConventions/#function-naming-patterns","title":"Function Naming Patterns","text":"Pattern Example Usage <code>GetProperty()</code> <code>GetPixelSize()</code> Accessor methods <code>SetProperty()</code> <code>SetRadius()</code> Mutator methods <code>ComputeX()</code> <code>ComputeChargeFraction()</code> Calculation methods <code>ConfigureX()</code> <code>ConfigureMessenger()</code> Setup methods <code>ProcessX()</code> <code>ProcessHits()</code> Action methods <code>IsCondition()</code> <code>IsInsidePixel()</code> Boolean queries"},{"location":"NamingConventions/#file-naming","title":"File Naming","text":"Pattern Example Content <code>ClassName.hh</code> <code>RunAction.hh</code> Class declaration <code>ClassName.cc</code> <code>RunAction.cc</code> Class implementation <code>UtilityName.hh</code> <code>NeighborhoodUtils.hh</code> Utility functions/classes <code>script.C</code> <code>FitGaus2D.C</code> ROOT macro scripts <code>script.mac</code> <code>run.mac</code> Geant4 macro commands"},{"location":"NamingConventions/#suggested-naming-improvements","title":"Suggested Naming Improvements","text":"<p>Based on the Tornago et al. paper (arXiv:2007.09528) terminology and standard physics conventions, the following naming changes are recommended to enhance clarity and alignment with established literature.</p>"},{"location":"NamingConventions/#enum-values","title":"Enum Values","text":"Current Name Suggested Name Rationale <code>PosReconModel::Log</code> <code>PosReconModel::LogA</code> Tornago paper uses \"LogA\" (Logarithmic Attenuation) consistently <code>PosReconModel::Linear</code> <code>PosReconModel::LinA</code> Tornago paper uses \"LinA\" (Linear Attenuation) consistently <code>ChargeMode::Patch</code> <code>ChargeMode::Neighborhood</code> More descriptive; matches \"neighborhood\" terminology used throughout <code>ChargeMode::FullGrid</code> <code>ChargeMode::FullMatrix</code> \"Matrix\" aligns with RSD matrix terminology in the paper"},{"location":"NamingConventions/#physics-parameters","title":"Physics Parameters","text":"Current Name Suggested Name Rationale <code>d0ChargeSharing</code> <code>d0</code> or <code>hitTransverseSize</code> Paper uses d\u2080 = 1 \u00b5m as \"transverse size of the hit\" <code>linearBetaNarrow</code> <code>betaSmallPitch</code> Clearer relation to pitch geometry <code>linearBetaWide</code> <code>betaLargePitch</code> Clearer relation to pitch geometry <code>amplificationFactor</code> <code>gain</code> Standard LGAD terminology; paper refers to \"gain\" <code>PIXEL_SPACING</code> <code>PIXEL_PITCH</code> \"Pitch\" is the standard term in the paper (e.g., \"pad-pitch geometry\") <code>PIXEL_SIZE</code> <code>PAD_SIZE</code> or <code>METAL_PAD_SIZE</code> Paper distinguishes \"pad size\" from \"pitch\""},{"location":"NamingConventions/#structclass-names","title":"Struct/Class Names","text":"Current Name Suggested Name Rationale <code>GridGeom</code> <code>PixelGridGeometry</code> More descriptive; avoids abbreviation <code>HitInfo</code> <code>ImpactPointInfo</code> Paper uses \"impact point\" terminology <code>ChargeMatrixSet</code> <code>SignalFractionSet</code> Paper uses \"signal fraction\" (F_i) rather than \"charge matrix\" <code>D0Params</code> <code>HitSizeParams</code> More physically meaningful"},{"location":"NamingConventions/#variable-names-internal","title":"Variable Names (Internal)","text":"Current Name Suggested Name Rationale <code>Fi</code> <code>signalFraction</code> F_i in paper is \"fraction of total signal amplitude\" <code>Qi</code> <code>chargeInduced</code> Clearer physics meaning <code>Qn</code> <code>chargeWithNoise</code> Explicit about noise contribution <code>Qf</code> <code>chargeFinal</code> Explicit final processed value <code>alpha</code> <code>angleOfView</code> Paper: \"\u03b1 is the angle of view of the pad\" <code>beta</code> <code>attenuationFactor</code> Paper: \"\u03b2 is the attenuation factor\""},{"location":"NamingConventions/#constants","title":"Constants","text":"Current Name Suggested Name Rationale <code>IONIZATION_ENERGY</code> <code>PAIR_CREATION_ENERGY</code> Standard silicon detector terminology (3.6 eV/pair) <code>DETECTOR_WIDTH</code> <code>DETECTOR_THICKNESS</code> \"Width\" is confusing; paper uses \"thickness\" (50 \u00b5m) <code>DPC_TOP_N_PIXELS</code> <code>DPC_CORNER_PADS</code> DPC uses exactly 4 corner pads by definition"},{"location":"NamingConventions/#function-names","title":"Function Names","text":"Current Name Suggested Name Rationale <code>CalcPixelAlphaSubtended</code> <code>ComputeAngleOfView</code> Matches paper terminology <code>ComputeChargeFractions</code> <code>ComputeSignalFractions</code> Paper uses \"signal fraction\" F_i <code>CalcNearestPixel</code> <code>FindNearestPad</code> \"Pad\" is preferred RSD terminology"},{"location":"NamingConventions/#root-branch-names_1","title":"ROOT Branch Names","text":"Current Name Suggested Name Rationale <code>charge_fractions</code> <code>signal_fractions</code> Aligns with Tornago F_i terminology <code>center_pixel_charge</code> <code>center_pad_signal</code> \"Pad\" and \"signal\" match paper conventions <code>neighborhood_sum</code> <code>total_signal_amplitude</code> Paper: \"A_tot = \u03a3 A[i]\""},{"location":"NamingConventions/#file-names","title":"File Names","text":"Current Name Suggested Name Rationale <code>FitGaus1D.C</code> <code>FitGaussian1D.C</code> Avoid abbreviation <code>FitGaus2D.C</code> <code>FitGaussian2D.C</code> Avoid abbreviation"},{"location":"NamingConventions/#terminology-mapping-code-tornago-paper","title":"Terminology Mapping: Code \u2194 Tornago Paper","text":"<p>This table maps simulation code terms to the corresponding Tornago et al. paper definitions:</p> Code Term Paper Term Paper Equation/Section <code>signalFraction</code> / <code>Fi</code> F_i Eq. 4: F_i(\u03b1_i, d_i) <code>d0</code> d\u2080 \"transverse size of hit\" = 1 \u00b5m <code>distance</code> d_i distance from hit to pad i metal edge <code>alpha</code> / <code>angleOfView</code> \u03b1_i angle of view of pad i <code>beta</code> / <code>attenuationFactor</code> \u03b2 LinA attenuation factor (Eq. 6) <code>pitch</code> pitch pad center-to-center spacing <code>padSize</code> / <code>metalSize</code> pad size / metal physical pad dimensions <code>interpad</code> pitch - metal gap between pads <code>DPC_Kx</code>, <code>DPC_Ky</code> k_x, k_y DPC coefficients (Fig. 7) <code>gain</code> gain LGAD multiplication factor (8-25 typical) <code>\u03b3</code> (gamma) \u03b3 delay factor in Eq. 5 <code>\u03b6</code> (zeta) \u03b6 LinA delay factor in Eq. 7"},{"location":"NamingConventions/#priority-recommendations","title":"Priority Recommendations","text":""},{"location":"NamingConventions/#high-priority-clarity-paper-alignment","title":"High Priority (Clarity &amp; Paper Alignment)","text":"<ol> <li>Rename <code>Log</code> \u2192 <code>LogA</code> and <code>Linear</code> \u2192 <code>LinA</code> \u2014 Direct paper terminology</li> <li>Rename <code>PIXEL_SPACING</code> \u2192 <code>PIXEL_PITCH</code> \u2014 Standard detector physics term</li> <li>Rename <code>Fi</code>, <code>Qi</code>, <code>Qn</code>, <code>Qf</code> \u2014 Single-letter names lack context</li> <li>Rename <code>amplificationFactor</code> \u2192 <code>gain</code> \u2014 Standard LGAD terminology</li> </ol>"},{"location":"NamingConventions/#medium-priority-consistency","title":"Medium Priority (Consistency)","text":"<ol> <li>Rename <code>GridGeom</code> \u2192 <code>PixelGridGeometry</code> \u2014 Avoid abbreviations</li> <li>Rename <code>d0ChargeSharing</code> \u2192 <code>d0</code> \u2014 Matches paper symbol</li> </ol>"},{"location":"NamingConventions/#low-priority-nice-to-have","title":"Low Priority (Nice to Have)","text":"<ol> <li>Rename <code>FitGaus*.C</code> \u2192 <code>FitGaussian*.C</code> \u2014 Avoid abbreviation</li> </ol>"},{"location":"NamingConventions/#summary","title":"Summary","text":"<p>The codebase follows consistent conventions: - Namespaces: <code>ECS::</code> for simulation code, <code>Constants::</code> for global values - Classes: PascalCase (<code>ChargeSharingCalculator</code>) - Member variables: f-prefix + PascalCase (<code>fPixelSize</code>) - Functions: PascalCase (<code>ComputeChargeFraction</code>) - Constants: SCREAMING_SNAKE_CASE (<code>PIXEL_SIZE</code>) - ROOT branches: snake_case (<code>charge_fractions</code>) - Enums: PascalCase for type, PascalCase for values (<code>PosReconModel::Log</code>)</p>"},{"location":"NamingConventions/#references","title":"References","text":"<ul> <li>Tornago, M. et al. \"Resistive AC-Coupled Silicon Detectors: principles of operation and first results from a combined analysis of beam test and laser data.\" arXiv:2007.09528v4 (2021). [NIMA]</li> </ul>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/","title":"Performance Optimization Report for epicChargeSharing","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#executive-summary","title":"Executive Summary","text":"<p>This report presents comprehensive optimization strategies for the epicChargeSharing Geant4/ROOT simulation. The recommendations are organized by impact level and implementation complexity, covering build configuration, Geant4-specific optimizations, ROOT I/O tuning, C++ code-level improvements, and advanced techniques for scaling.</p> <p>Key Findings: - Your codebase is already well-optimized with LTO, C++20, and fast EM physics - The highest-impact quick win is fixing string comparisons in <code>SteppingAction.cc</code> - ROOT I/O currently uses no compression (<code>SetCompressionLevel(0)</code>) - enabling ZSTD can reduce file sizes by 50-70% - Several compute-intensive loops can benefit from SIMD vectorization and cache optimization</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Build System Optimizations</li> <li>Geant4-Specific Optimizations</li> <li>ROOT I/O Optimizations</li> <li>Code-Level Optimizations</li> <li>Memory &amp; Cache Optimizations</li> <li>SIMD &amp; Vectorization</li> <li>Distributed &amp; Cluster Computing</li> <li>Profiling &amp; Benchmarking</li> <li>Geant4 11.3 New Features</li> <li>Implementation Priority Matrix</li> </ol>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#1-build-system-optimizations","title":"1. Build System Optimizations","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#11-current-strengths","title":"1.1 Current Strengths \u2713","text":"<p>Your <code>CMakeLists.txt</code> already includes excellent optimizations: - LTO (Link-Time Optimization) enabled for Release builds - Release mode defaults with <code>-O3</code> - <code>-funroll-loops</code> for release builds - Optional <code>-ffast-math</code> and <code>-march=native</code> via <code>EC_FAST_MATH</code> - Profiling support via <code>EC_PROFILE</code></p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#12-profile-guided-optimization-pgo","title":"1.2 Profile-Guided Optimization (PGO)","text":"<p>PGO provides 10-20% speedup by optimizing based on actual runtime behavior:</p> <pre><code># Add to CMakeLists.txt\noption(EC_PGO_GENERATE \"Generate PGO profile data\" OFF)\noption(EC_PGO_USE \"Use PGO profile data for optimization\" OFF)\n\nif(EC_PGO_GENERATE AND CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n    list(APPEND _project_compile_options -fprofile-generate=${CMAKE_BINARY_DIR}/pgo)\n    list(APPEND _project_link_options -fprofile-generate=${CMAKE_BINARY_DIR}/pgo)\n    message(STATUS \"PGO: Profile generation enabled -&gt; ${CMAKE_BINARY_DIR}/pgo\")\nelseif(EC_PGO_USE AND CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n    list(APPEND _project_compile_options\n        -fprofile-use=${CMAKE_BINARY_DIR}/pgo\n        -fprofile-correction)\n    list(APPEND _project_link_options -fprofile-use=${CMAKE_BINARY_DIR}/pgo)\n    message(STATUS \"PGO: Using profile data for optimization\")\nendif()\n</code></pre> <p>Usage workflow: <pre><code># Step 1: Build with profiling instrumentation\ncmake -DEC_PGO_GENERATE=ON -DCMAKE_BUILD_TYPE=Release ..\nmake -j$(nproc)\n./epicChargeSharing run.mac  # Run representative workload (1000+ events)\n\n# Step 2: Rebuild optimized with profile data\ncmake -DEC_PGO_GENERATE=OFF -DEC_PGO_USE=ON ..\nmake -j$(nproc)\n</code></pre></p> <p>PGO is particularly effective because it optimizes branch prediction in your hot loops in <code>ComputeChargeFractions</code> and <code>ComputeFullGridFractions</code>.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#13-additional-compiler-flags","title":"1.3 Additional Compiler Flags","text":"<pre><code>if(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n    # Better branch prediction layout\n    list(APPEND _project_release_compile_options -fno-plt)\n\n    # Enable OpenMP SIMD pragmas without full threading\n    list(APPEND _project_release_compile_options -fopenmp-simd)\n\n    # Disable errno checking for math functions (4x+ speedup for sqrt/log)\n    list(APPEND _project_release_compile_options -fno-math-errno)\n\n    # Allow reordering of floating-point operations\n    list(APPEND _project_release_compile_options -ffp-contract=fast)\nendif()\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#14-architecture-specific-tuning","title":"1.4 Architecture-Specific Tuning","text":"<pre><code># Identify your CPU architecture\ngcc -march=native -Q --help=target | grep march\n\n# Common architecture options:\n# -march=znver4      # AMD Zen 4 (Ryzen 7000/EPYC Genoa)\n# -march=znver3      # AMD Zen 3 (Ryzen 5000)\n# -march=alderlake   # Intel 12th/13th Gen\n# -march=skylake     # Intel 6th-10th Gen\n# -march=neoverse-n1 # ARM Graviton2/Ampere Altra\n</code></pre> <p>References: - CMake Build Optimization - GCC Optimization Options</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#2-geant4-specific-optimizations","title":"2. Geant4-Specific Optimizations","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#21-physics-list-selection","title":"2.1 Physics List Selection \u2713","text":"<p>Your current configuration uses <code>G4EmStandardPhysics_option1</code> (EMV), which is the fastest EM physics option:</p> Constructor Speed Accuracy Best Use Case <code>_option1</code> (EMV) \u2713 Fastest Good HEP, fast simulations <code>_option2</code> (EMX) Fast Good General purpose <code>_option3</code> (EMY) Medium High Medical, low-energy <code>_option4</code> Slow Highest Precision benchmarks <p>Your setup is optimal for speed.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#22-production-cut-optimization","title":"2.2 Production Cut Optimization","text":"<p>Your current 50 \u00b5m cut is quite fine. Consider region-specific cuts for better performance:</p> <pre><code>// PhysicsList.cc - Region-specific cuts for optimal performance\nvoid PhysicsList::SetCuts()\n{\n    // Fine cuts in sensitive silicon region\n    G4Region* siliconRegion = G4RegionStore::GetInstance()-&gt;GetRegion(\"SiliconRegion\");\n    if (siliconRegion) {\n        G4ProductionCuts* cuts = new G4ProductionCuts();\n        cuts-&gt;SetProductionCut(10.0*CLHEP::micrometer, \"gamma\");\n        cuts-&gt;SetProductionCut(10.0*CLHEP::micrometer, \"e-\");\n        cuts-&gt;SetProductionCut(10.0*CLHEP::micrometer, \"e+\");\n        siliconRegion-&gt;SetProductionCuts(cuts);\n    }\n\n    // Coarse cuts elsewhere for speed\n    SetDefaultCutValue(1.0*CLHEP::millimeter);\n}\n</code></pre> <p>Impact: Production cuts have roughly exponential impact on simulation time. Doubling the cut can reduce simulation time by 30-50% in high-energy scenarios.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#23-steppingaction-optimization-high-priority","title":"2.3 SteppingAction Optimization \u26a0\ufe0f HIGH PRIORITY","text":"<p>Current Issue in <code>SteppingAction.cc:41</code>: <pre><code>// SLOW: String comparison on EVERY step!\nconst G4String enteredName = postVol-&gt;GetLogicalVolume()-&gt;GetName();\nif (enteredName == \"logicBlock\" || enteredName == \"logicCube\") {\n</code></pre></p> <p>String comparison costs ~100+ CPU cycles per step. With millions of steps per run, this is a significant overhead.</p> <p>Optimized implementation using pointer comparison:</p> <pre><code>// SteppingAction.hh - Add cached volume pointers\nclass SteppingAction : public G4UserSteppingAction {\nprivate:\n    const G4LogicalVolume* fLogicBlock = nullptr;\n    const G4LogicalVolume* fLogicCube = nullptr;\n    bool fVolumesCached = false;\n\n    void CacheVolumes();\n};\n\n// SteppingAction.cc\n#include \"G4LogicalVolumeStore.hh\"\n\nvoid SteppingAction::CacheVolumes() {\n    if (fVolumesCached) return;\n\n    auto* lvStore = G4LogicalVolumeStore::GetInstance();\n    fLogicBlock = lvStore-&gt;GetVolume(\"logicBlock\", false);\n    fLogicCube = lvStore-&gt;GetVolume(\"logicCube\", false);\n    fVolumesCached = true;\n}\n\nvoid SteppingAction::TrackVolumeInteractions(const G4Step* step) {\n    if (fFirstContactVolume != \"NONE\") return;\n\n    CacheVolumes();  // One-time initialization\n\n    G4StepPoint* postPoint = step-&gt;GetPostStepPoint();\n    if (!postPoint || postPoint-&gt;GetStepStatus() != fGeomBoundary) return;\n\n    G4VPhysicalVolume* postVol = postPoint-&gt;GetTouchableHandle()-&gt;GetVolume();\n    if (!postVol) return;\n\n    // FAST: Pointer comparison (~3 cycles vs ~100+ for string)\n    const G4LogicalVolume* lv = postVol-&gt;GetLogicalVolume();\n    if (lv == fLogicBlock || lv == fLogicCube) {\n        fFirstContactVolume = lv-&gt;GetName();  // Only retrieve name when needed\n        if (fEventAction) {\n            fEventAction-&gt;RegisterFirstContact(postPoint-&gt;GetPosition());\n        }\n    }\n}\n</code></pre> <p>Expected speedup: 10-50x for volume identification logic.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#24-use-const-references-for-g4threevector","title":"2.4 Use const References for G4ThreeVector","text":"<p>The Geant4 documentation recommends using const references for composite types:</p> <pre><code>// SLOW: Copies G4ThreeVector\nG4ThreeVector pos = step-&gt;GetPreStepPoint()-&gt;GetPosition();\n\n// FAST: Uses reference, avoids copy\nconst G4ThreeVector&amp; pos = step-&gt;GetPreStepPoint()-&gt;GetPosition();\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#25-scorer-vs-sensitive-detector","title":"2.5 Scorer vs Sensitive Detector","text":"<p>Your current approach using <code>G4SDManager</code> and <code>G4THitsMap</code> is good. Key optimization:</p> <pre><code>// EventAction.cc:338 - Cache the collection ID\nvoid EventAction::CollectScorerData(const G4Event* event)\n{\n    // GOOD: You're caching edepID as static\n    static G4int edepID = -1;\n    if (edepID &lt; 0) {\n        if (auto* sdm = G4SDManager::GetSDMpointer()) {\n            edepID = sdm-&gt;GetCollectionID(\"SiliconDetector/EnergyDeposit\");\n        }\n    }\n    // GetCollectionID() is expensive - caching is correct!\n}\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#26-multithreading-configuration","title":"2.6 Multithreading Configuration","text":"<pre><code>// Optimal thread configuration in main()\n#ifdef G4MULTITHREADED\n    G4int nCores = G4Threading::G4GetNumberOfCores();\n    // Physical cores only - hyperthreading provides no benefit for Geant4\n    G4int nThreads = std::max(1, nCores - 1);  // Leave 1 for OS\n    runManager-&gt;SetNumberOfThreads(nThreads);\n\n    // Use MIXMAX for MT (guaranteed divergent sequences)\n    CLHEP::HepRandom::setTheEngine(new CLHEP::MixMaxRng);\n#endif\n</code></pre> <p>References: - Geant4 Performance Tips - CERN TWiki - Geant4 EM Physics Guide - Geant4 Multithreading</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#3-root-io-optimizations","title":"3. ROOT I/O Optimizations","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#31-current-issue-no-compression","title":"3.1 Current Issue: No Compression \u26a0\ufe0f","text":"<p>In <code>RunAction.cc:318</code>: <pre><code>rootFile-&gt;SetCompressionLevel(0);  // NO COMPRESSION!\n</code></pre></p> <p>This means your ROOT files are uncompressed, which: - Increases disk I/O time - Wastes storage space - Slows down file merging</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#32-recommended-compression-settings","title":"3.2 Recommended Compression Settings","text":"<pre><code>// RunAction.cc - Replace SetCompressionLevel(0) with:\n#include \"TFile.h\"\n#include \"Compression.h\"\n\n// ZSTD: Best balance of speed and compression\nrootFile-&gt;SetCompressionAlgorithm(ROOT::RCompressionSetting::EAlgorithm::kZSTD);\nrootFile-&gt;SetCompressionLevel(4);  // 1-9, 4 is good balance\n\n// Alternative: LZ4 for maximum write speed (less compression)\n// rootFile-&gt;SetCompressionAlgorithm(ROOT::RCompressionSetting::EAlgorithm::kLZ4);\n// rootFile-&gt;SetCompressionLevel(4);\n</code></pre> Algorithm Write Speed Read Speed Compression Ratio None (current) Fastest Fastest 1.0x LZ4 Very Fast Very Fast 2-3x ZSTD \u2713 Fast Fast 3-5x ZLIB Slow Medium 3-4x"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#33-ttree-configuration","title":"3.3 TTree Configuration","text":"<p>Your current settings in <code>RunAction.cc:323-324</code>: <pre><code>tree-&gt;SetAutoSave(0);   // Disabled\ntree-&gt;SetAutoFlush(0);  // Disabled\n</code></pre></p> <p>Recommended settings: <pre><code>// Enable AutoFlush for better read performance\ntree-&gt;SetAutoFlush(50000);  // Flush every 50k entries\n\n// Or use byte-based flushing (default is 30MB)\ntree-&gt;SetAutoFlush(-30000000);  // Negative = bytes\n\n// OptimizeBaskets after filling some entries\n// Call this after ~1000 events to auto-tune buffer sizes\ntree-&gt;OptimizeBaskets(256000000, 1.0, \"\");  // 256MB max memory\n</code></pre></p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#34-basket-size-for-vector-branches","title":"3.4 Basket Size for Vector Branches","text":"<p>Your vector branches use 256KB baskets (good!): <pre><code>constexpr Int_t bufsize = 256000;  // 256KB - already optimized \u2713\n</code></pre></p> <p>For very large grids (full detector fractions), consider: <pre><code>// For branches with &gt;10KB per entry\ntree-&gt;SetBasketSize(\"FiGrid\", 512000);\ntree-&gt;SetBasketSize(\"QfGrid\", 512000);\n</code></pre></p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#35-future-migrate-to-rntuple","title":"3.5 Future: Migrate to RNTuple","text":"<p>ROOT's RNTuple (production-ready in ROOT 6.36, Q2 2025) offers: - 2-5x faster read throughput - 20-35% smaller files - Better multicore scalability (&gt;100 threads tested)</p> <pre><code>// Future-proof preparation\n#include \"RVersion.h\"\n#if ROOT_VERSION_CODE &gt;= ROOT_VERSION(6,36,0)\n    #include \"ROOT/RNTuple.hxx\"\n    // Use RNTuple API\n#endif\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#36-rdataframe-for-analysis","title":"3.6 RDataFrame for Analysis","text":"<p>For reading and analyzing your ROOT files:</p> <pre><code>// Enable implicit multithreading\nROOT::EnableImplicitMT();\n\n// Use RDataFrame instead of TTree loops\nROOT::RDataFrame df(\"Hits\", \"epicChargeSharing.root\");\n\nauto h = df.Filter(\"Edep &gt; 0\")\n           .Define(\"deltaR\", \"sqrt(ReconTrueDeltaX*ReconTrueDeltaX + ReconTrueDeltaY*ReconTrueDeltaY)\")\n           .Histo1D(\"deltaR\");\n</code></pre> <p>References: - ROOT TTree Manual - RNTuple Update 2024 - RDataFrame Performance</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#4-code-level-optimizations","title":"4. Code-Level Optimizations","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#41-chargesharingcalculator-duplicate-weight-computation","title":"4.1 ChargeSharingCalculator: Duplicate Weight Computation","text":"<p>In <code>ComputeChargeFractions()</code> (lines ~510-575), weights are computed twice:</p> <pre><code>// First computation (line ~388-396)\nconst G4double safeDistance = std::max(distance, d0p.minSafeDistance);\nconst G4double logValue = std::log(safeDistance * d0p.invLength);\nG4double weight = (logValue &gt; 0.0 &amp;&amp; std::isfinite(logValue)) ? (alpha / logValue) : 0.0;\n\n// ... later, RECOMPUTED (line ~519-528)\nconst G4double safeDistance = std::max(distance, d0p.minSafeDistance);  // DUPLICATE\nconst G4double logValue = std::log(safeDistance * d0p.invLength);       // DUPLICATE\n</code></pre> <p>Solution: Store original weights in the scratch buffer:</p> <pre><code>// Modify WeightScratch to store both original and modified weights\nstruct WeightPair {\n    G4double original;\n    G4double modified;\n};\nstd::vector&lt;WeightPair&gt; fWeightScratch;\n\n// In ComputeChargeFractions:\nfWeightScratch.push_back({weight, weight});  // Store original\n\n// Later, for row/col sums, use fWeightScratch[i].original\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#42-precompute-loop-invariants","title":"4.2 Precompute Loop Invariants","text":"<p>In <code>ComputeFullGridFractions()</code>, move invariants outside loops:</p> <pre><code>// Current: computed inside nested loops\nconst G4double alpha = CalcPixelAlphaSubtended(distance, pixelSize, pixelSize);\n\n// Optimization: precompute constants\nconst G4double halfDiag = (pixelSize * 0.5) * 1.41421356237;  // sqrt(2)\nconst G4double invD0 = d0p.invLength;\nconst G4double betaInvMicron = chargeModel.beta * chargeModel.invMicron;\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#43-use-c20-likelyunlikely-attributes","title":"4.3 Use C++20 [[likely]]/[[unlikely]] Attributes","text":"<p>For predictable branches in hot paths:</p> <pre><code>void SteppingAction::TrackVolumeInteractions(const G4Step* step) {\n    if (fFirstContactVolume != \"NONE\") [[likely]] {\n        return;  // Most steps don't change contact\n    }\n\n    // ... rest of function\n}\n\n// In ComputeChargeFractions\nif (cell.gridIndex &lt; 0) [[unlikely]] {\n    continue;\n}\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#44-avoid-stdvector-reallocations","title":"4.4 Avoid std::vector Reallocations","text":"<p>Your code already reserves buffers (good!), but ensure consistency:</p> <pre><code>// ChargeSharingCalculator.cc - ReserveBuffers()\nvoid ChargeSharingCalculator::ReserveBuffers() {\n    const std::size_t maxCells = static_cast&lt;std::size_t&gt;(fGridDim) * fGridDim;\n\n    // Pre-allocate to avoid reallocations\n    if (fResult.cells.capacity() &lt; maxCells) {\n        fResult.cells.reserve(maxCells);\n    }\n    if (fWeightScratch.capacity() &lt; maxCells) {\n        fWeightScratch.reserve(maxCells);\n    }\n\n    // Also reserve chargeBlock (always max 4)\n    fResult.chargeBlock.reserve(4);\n}\n</code></pre> <p>References: - Agner Fog's Optimization Manual - C++ likely/unlikely attributes</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#5-memory-cache-optimizations","title":"5. Memory &amp; Cache Optimizations","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#51-false-sharing-prevention","title":"5.1 False Sharing Prevention","text":"<p>In multithreaded scenarios, ensure thread-local data doesn't share cache lines:</p> <pre><code>// Potential false sharing in RunAction if accessed from multiple threads\nstruct alignas(64) ThreadLocalData {  // 64-byte alignment = cache line\n    G4double fEdep;\n    G4double fTrueX;\n    G4double fTrueY;\n    // ... pad to 64 bytes if needed\n    char padding[64 - 3*sizeof(G4double)];\n};\n</code></pre> <p>For your current single-threaded per-worker design, this isn't critical, but good to know for future scaling.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#52-cache-friendly-access-patterns","title":"5.2 Cache-Friendly Access Patterns","text":"<p>Your <code>Grid2D</code> template uses row-major storage (correct for C++):</p> <pre><code>// Grid2D::operator() - Row-major access\nconst auto idx = static_cast&lt;std::size_t&gt;(row) * nCols + col;\n</code></pre> <p>Ensure loops iterate row-first: <pre><code>// GOOD: Sequential memory access\nfor (G4int i = 0; i &lt; rows; ++i) {\n    for (G4int j = 0; j &lt; cols; ++j) {\n        grid(i, j) = ...;  // Accesses grid[i*cols + j]\n    }\n}\n\n// BAD: Strided access (cache misses)\nfor (G4int j = 0; j &lt; cols; ++j) {\n    for (G4int i = 0; i &lt; rows; ++i) {\n        grid(i, j) = ...;  // Jumps by 'cols' each iteration\n    }\n}\n</code></pre></p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#53-g4allocator-for-custom-hit-classes","title":"5.3 G4Allocator for Custom Hit Classes","text":"<p>If you create custom hit classes, use G4Allocator for memory pooling:</p> <pre><code>class MyHit : public G4VHit {\npublic:\n    inline void* operator new(size_t);\n    inline void operator delete(void*);\n\nprivate:\n    static G4ThreadLocal G4Allocator&lt;MyHit&gt;* fAllocator;\n};\n\ninline void* MyHit::operator new(size_t) {\n    if (!fAllocator) fAllocator = new G4Allocator&lt;MyHit&gt;;\n    return (void*)fAllocator-&gt;MallocSingle();\n}\n\ninline void MyHit::operator delete(void* hit) {\n    fAllocator-&gt;FreeSingle((MyHit*)hit);\n}\n</code></pre> <p>References: - False Sharing in C++ - G4Allocator Documentation</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#6-simd-vectorization","title":"6. SIMD &amp; Vectorization","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#61-enable-auto-vectorization","title":"6.1 Enable Auto-Vectorization","text":"<p>Add compiler hints for vectorizable loops:</p> <pre><code>// In hot loops like ComputeFullGridFractions\n#pragma omp simd\nfor (G4int i = 0; i &lt; rows; ++i) {\n    // Loop body should be simple for vectorization\n}\n</code></pre> <p>Compile with <code>-fopenmp-simd</code> to enable SIMD pragmas without full OpenMP threading.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#62-why-standard-math-is-slow","title":"6.2 Why Standard Math is Slow","text":"<p>Without <code>-fno-math-errno</code>, <code>std::sqrt</code> and <code>std::log</code> must set <code>errno</code> on error, preventing vectorization:</p> <pre><code>// Standard sqrt: ~12-14 cycles, non-vectorized\ndouble d = std::sqrt(x);\n\n// With -fno-math-errno: vectorized, ~3-4 cycles per element\n// Add to CMakeLists.txt:\nlist(APPEND _project_release_compile_options -fno-math-errno)\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#63-consider-eigen-for-matrix-operations","title":"6.3 Consider Eigen for Matrix Operations","text":"<p>For intensive grid computations, Eigen provides auto-vectorized operations:</p> <pre><code>#include &lt;Eigen/Dense&gt;\n\n// Instead of manual Grid2D operations\nEigen::MatrixXd weights(rows, cols);\nEigen::MatrixXd fractions = weights / weights.sum();\n</code></pre> <p>Eigen auto-vectorizes with SSE/AVX/NEON and provides 2-10x speedups for dense matrix operations.</p> <p>References: - Why C++ Math is Slow - Eigen Library - SIMD for C++ Developers</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#7-distributed-cluster-computing","title":"7. Distributed &amp; Cluster Computing","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#71-mpi-for-multi-node-scaling","title":"7.1 MPI for Multi-Node Scaling","text":"<p>For cluster computing, Geant4 supports hybrid MPI+MT:</p> <pre><code>// Example using G4MPImanager\n#include \"G4MPImanager.hh\"\n#include \"G4MPIsession.hh\"\n\nint main(int argc, char** argv) {\n    G4MPImanager* g4MPI = new G4MPImanager(argc, argv);\n    G4MPIsession* session = g4MPI-&gt;GetMPIsession();\n\n    // Each MPI rank runs MT workers\n    G4MTRunManager* runManager = new G4MTRunManager;\n    runManager-&gt;SetNumberOfThreads(G4Threading::G4GetNumberOfCores());\n\n    // ... setup and run\n\n    delete g4MPI;\n}\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#72-simple-multi-process-parallelization","title":"7.2 Simple Multi-Process Parallelization","text":"<p>Without MPI, use GNU Parallel for embarrassingly parallel runs:</p> <pre><code>#!/bin/bash\n# Run 8 independent simulations with different seeds\nparallel -j 8 './epicChargeSharing -s {} run.mac' ::: $(seq 1 8)\n\n# Merge output files\nhadd -f epicChargeSharing_merged.root epicChargeSharing_*.root\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#73-job-arrays-on-hpc-clusters","title":"7.3 Job Arrays on HPC Clusters","text":"<p>For SLURM clusters: <pre><code>#!/bin/bash\n#SBATCH --array=1-100\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=8\n\n./epicChargeSharing -s $SLURM_ARRAY_TASK_ID run.mac\n</code></pre></p> <p>References: - Geant4 MPI Extension - ParGeant4</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#8-profiling-benchmarking","title":"8. Profiling &amp; Benchmarking","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#81-linux-perf-recommended","title":"8.1 Linux perf (Recommended)","text":"<pre><code># Record with call graph\nperf record -g --call-graph dwarf ./epicChargeSharing run.mac\n\n# Interactive analysis\nperf report --hierarchy\n\n# Flame graph (install flamegraph.pl)\nperf script | stackcollapse-perf.pl | flamegraph.pl &gt; profile.svg\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#82-valgrind-cachegrind","title":"8.2 Valgrind Cachegrind","text":"<pre><code># Simulate cache behavior\nvalgrind --tool=cachegrind ./epicChargeSharing run.mac\n\n# View results\ncg_annotate --auto=yes cachegrind.out.*\n\n# Key metrics:\n# D1mr: L1 data cache read misses\n# DLmr: Last-level cache read misses (most expensive)\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#83-intel-vtune-if-available","title":"8.3 Intel VTune (if available)","text":"<pre><code>vtune -collect hotspots ./epicChargeSharing run.mac\nvtune -report hotspots -r r000hs\n</code></pre>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#84-built-in-timing","title":"8.4 Built-in Timing","text":"<p>Add timing instrumentation:</p> <pre><code>#include &lt;chrono&gt;\n#include \"G4Timer.hh\"\n\n// In RunAction\nG4Timer fRunTimer;\n\nvoid RunAction::BeginOfRunAction(const G4Run*) {\n    fRunTimer.Start();\n}\n\nvoid RunAction::EndOfRunAction(const G4Run* run) {\n    fRunTimer.Stop();\n    G4int nEvents = run-&gt;GetNumberOfEvent();\n    G4double wallTime = fRunTimer.GetRealElapsed();\n    G4cout &lt;&lt; \"Performance: \" &lt;&lt; nEvents / wallTime &lt;&lt; \" events/second\" &lt;&lt; G4endl;\n    G4cout &lt;&lt; \"Time per event: \" &lt;&lt; 1000.0 * wallTime / nEvents &lt;&lt; \" ms\" &lt;&lt; G4endl;\n}\n</code></pre> <p>References: - Linux perf wiki - Intel VTune</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#9-geant4-113-new-features","title":"9. Geant4 11.3 New Features","text":"<p>Released December 2024, Geant4 11.3 includes several performance improvements:</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#91-parallel-geometry-voxelization","title":"9.1 Parallel Geometry Voxelization","text":"<p>Enable multi-threaded geometry initialization:</p> <pre><code>#include \"G4GeometryManager.hh\"\n\n// In DetectorConstruction::Construct()\nG4GeometryManager::GetInstance()-&gt;RequestParallelOptimisation(true, true);\n</code></pre> <p>This accelerates voxel tree construction for complex geometries.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#92-dynamic-particle-processing","title":"9.2 Dynamic Particle Processing","text":"<p>New classes (<code>G4DynamicParticleIonisation</code>, <code>G4DynamicParticleMSC</code>) perform computations on-the-fly without particle definition lookups.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#93-optimized-urbanmsc-model","title":"9.3 Optimized UrbanMsc Model","text":"<p><code>G4UrbanMscModel</code> has an optimized step limitation algorithm in EM Opt3 physics.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#94-faster-cross-section-calculations","title":"9.4 Faster Cross-Section Calculations","text":"<p><code>G4ChargeExchangeXS</code> now computes at element level instead of isotope level - several times faster.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#95-improved-task-distribution","title":"9.5 Improved Task Distribution","text":"<p><code>G4TaskRunManager</code> now distributes events more evenly across tasks, improving load balancing.</p> <p>References: - Geant4 11.3 Release Notes - 2025 Planned Features</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#10-implementation-priority-matrix","title":"10. Implementation Priority Matrix","text":"Optimization Impact Effort Priority SteppingAction pointer comparison High Low P0 Enable ROOT compression (ZSTD) High Low P0 Enable <code>-fno-math-errno</code> Medium-High Low P0 Profile-Guided Optimization High Medium P1 Cache weight calculations Medium Medium P1 TTree AutoFlush tuning Medium Low P1 Region-specific production cuts Medium Medium P2 [[likely]]/[[unlikely]] hints Low-Medium Low P2 SIMD vectorization Medium High P3 Migrate to RNTuple High High Future"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#quick-wins-implement-today","title":"Quick Wins (Implement Today)","text":"<ol> <li>SteppingAction fix - Replace string comparison with pointer comparison</li> <li>Enable ZSTD compression - Change <code>SetCompressionLevel(0)</code> to <code>SetCompressionAlgorithm(kZSTD)</code> + level 4</li> <li>Add <code>-fno-math-errno</code> - 4x+ speedup for math functions</li> <li>Build with <code>-DEC_FAST_MATH=ON</code> - Already supported in your CMake</li> </ol>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#medium-term-this-week","title":"Medium-Term (This Week)","text":"<ol> <li>Run profiling with <code>perf</code> to identify actual hotspots</li> <li>Implement PGO for 10-20% overall speedup</li> <li>Enable AutoFlush for better ROOT file structure</li> <li>Add timing instrumentation to measure improvements</li> </ol>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#long-term-future-releases","title":"Long-Term (Future Releases)","text":"<ol> <li>Consider RNTuple when ROOT 6.36 is stable</li> <li>Evaluate Eigen for matrix operations if compute-bound</li> <li>Implement MPI support for cluster scaling</li> </ol>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#summary","title":"Summary","text":"<p>Your codebase is already well-architected with good separation of concerns and reasonable defaults. The highest-impact improvements are:</p> Change Expected Impact Lines to Change SteppingAction pointer comparison 10-50x for volume ID ~20 lines Enable ZSTD compression 50-70% smaller files 2 lines <code>-fno-math-errno</code> flag 4x faster sqrt/log 1 CMake line PGO build 10-20% overall CMake + workflow <p>Recommended first step: Run <code>perf record -g ./epicChargeSharing run.mac</code> and analyze the flame graph to confirm where time is actually spent before making changes.</p>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#references-further-reading","title":"References &amp; Further Reading","text":""},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#geant4","title":"Geant4","text":"<ul> <li>Geant4 Performance Tips</li> <li>Geant4 11.3 Release Notes</li> <li>Geant4 2025 Planned Features</li> <li>Geant4 Multithreading</li> </ul>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#root","title":"ROOT","text":"<ul> <li>ROOT TTree Manual</li> <li>RNTuple Update 2024</li> <li>RDataFrame Performance</li> <li>ROOT I/O Compression</li> </ul>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#c-optimization","title":"C++ Optimization","text":"<ul> <li>Agner Fog's Optimization Manual</li> <li>Data-Oriented Design (Mike Acton)</li> <li>Why C++ Math Functions Are Slow</li> <li>False Sharing Prevention</li> <li>Eigen Linear Algebra Library</li> </ul>"},{"location":"PERFORMANCE_OPTIMIZATION_REPORT/#profiling","title":"Profiling","text":"<ul> <li>Linux perf wiki</li> <li>Flame Graphs</li> <li>Intel VTune</li> </ul> <p>Report generated: December 2025 Based on: Geant4 11.3, ROOT 6.x, GCC/Clang with C++20 Codebase analyzed: epicChargeSharing (AC-LGAD charge sharing simulation)</p>"},{"location":"ROOT_OUTPUT_BRANCHES/","title":"ROOT File Output Branches Report","text":""},{"location":"ROOT_OUTPUT_BRANCHES/#overview","title":"Overview","text":"<p>The epicChargeSharing simulation outputs a ROOT file (<code>epicChargeSharing.root</code>) containing a TTree named <code>tree</code> with event-by-event data. The branches saved depend on configuration settings in <code>Config.hh</code>.</p>"},{"location":"ROOT_OUTPUT_BRANCHES/#configuration-controls","title":"Configuration Controls","text":"Setting Location Default Description <code>DENOMINATOR_MODE</code> <code>Config.hh:197</code> <code>Neighborhood</code> Controls which fraction/charge branches are saved <code>STORE_FULL_GRID</code> <code>Config.hh:222</code> <code>true</code> Whether to save full detector grid data <code>NEIGHBORHOOD_RADIUS</code> <code>Config.hh:221</code> <code>2</code> Neighborhood size (2 = 5x5 grid = 25 pixels)"},{"location":"ROOT_OUTPUT_BRANCHES/#branch-categories","title":"Branch Categories","text":""},{"location":"ROOT_OUTPUT_BRANCHES/#1-scalar-branches-always-saved","title":"1. Scalar Branches (Always Saved)","text":"<p>These branches store one value per event.</p> Branch Type Unit Description <code>TrueX</code> Double mm True hit X position <code>TrueY</code> Double mm True hit Y position <code>PixelX</code> Double mm Nearest pixel center X <code>PixelY</code> Double mm Nearest pixel center Y <code>Edep</code> Double MeV Energy deposited in event <code>PixelTrueDeltaX</code> Double mm <code>PixelX - TrueX</code> <code>PixelTrueDeltaY</code> Double mm <code>PixelY - TrueY</code> <code>ReconX</code> Double mm Reconstructed X position <code>ReconY</code> Double mm Reconstructed Y position <code>ReconTrueDeltaX</code> Double mm <code>ReconX - TrueX</code> <code>ReconTrueDeltaY</code> Double mm <code>ReconY - TrueY</code>"},{"location":"ROOT_OUTPUT_BRANCHES/#2-classification-branches-always-saved","title":"2. Classification Branches (Always Saved)","text":"Branch Type Description <code>isPixelHit</code> Bool Whether hit landed on a pixel <code>NeighborhoodSize</code> Int Number of active cells in neighborhood <code>NearestPixelI</code> Int Row index of nearest pixel <code>NearestPixelJ</code> Int Column index of nearest pixel <code>NearestPixelID</code> Int Global ID of nearest pixel"},{"location":"ROOT_OUTPUT_BRANCHES/#3-common-vector-branches-always-saved","title":"3. Common Vector Branches (Always Saved)","text":"<p>These are <code>std::vector&lt;Double_t&gt;</code> with size = neighborhood capacity (25 for radius=2).</p> Branch Description <code>NeighborhoodPixelX</code> X coordinates of neighborhood pixel centers <code>NeighborhoodPixelY</code> Y coordinates of neighborhood pixel centers <code>NeighborhoodPixelID</code> Global IDs of neighborhood pixels (<code>std::vector&lt;Int_t&gt;</code>) <code>d_i</code> Distance from hit to each pixel center <code>alpha_i</code> Solid angle subtended by each pixel"},{"location":"ROOT_OUTPUT_BRANCHES/#4-mode-specific-neighborhood-branches","title":"4. Mode-Specific Neighborhood Branches","text":"<p>Controlled by: <code>Constants::DENOMINATOR_MODE</code> in <code>Config.hh:197</code></p>"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-neighborhood-default","title":"Mode: <code>Neighborhood</code> (Default)","text":"<p>Fractions normalized by sum over all neighborhood pixels: <code>F_i = w_i / \u03a3_neighborhood(w_n)</code></p> Branch Type Description <code>Fi</code> <code>vector&lt;Double&gt;</code> Signal fraction (neighborhood denominator) <code>Qi</code> <code>vector&lt;Double&gt;</code> Induced charge = <code>Fi * Q_total</code> <code>Qn</code> <code>vector&lt;Double&gt;</code> Charge after gain noise <code>Qf</code> <code>vector&lt;Double&gt;</code> Final charge after additive noise"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-rowcol","title":"Mode: <code>RowCol</code>","text":"<p>Fractions normalized by row/column sums: <code>F_i_row = w_i / \u03a3_row(w_n)</code>, <code>F_i_col = w_i / \u03a3_col(w_n)</code></p> Branch Type Description <code>FiRow</code> <code>vector&lt;Double&gt;</code> Signal fraction (row denominator) <code>FiCol</code> <code>vector&lt;Double&gt;</code> Signal fraction (column denominator) <code>QiRow</code> <code>vector&lt;Double&gt;</code> Row-based induced charge <code>QnRow</code> <code>vector&lt;Double&gt;</code> Row-based charge after gain noise <code>QfRow</code> <code>vector&lt;Double&gt;</code> Row-based final charge <code>QiCol</code> <code>vector&lt;Double&gt;</code> Column-based induced charge <code>QnCol</code> <code>vector&lt;Double&gt;</code> Column-based charge after gain noise <code>QfCol</code> <code>vector&lt;Double&gt;</code> Column-based final charge"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-chargeblock","title":"Mode: <code>ChargeBlock</code>","text":"<p>Fractions normalized by sum of 4 closest pixels: <code>F_i_block = w_i / \u03a3_4closest(w_n)</code></p> Branch Type Description <code>FiBlock</code> <code>vector&lt;Double&gt;</code> Signal fraction (4-pixel block denominator) <code>QiBlock</code> <code>vector&lt;Double&gt;</code> Block-based induced charge <code>QnBlock</code> <code>vector&lt;Double&gt;</code> Block-based charge after gain noise <code>QfBlock</code> <code>vector&lt;Double&gt;</code> Block-based final charge"},{"location":"ROOT_OUTPUT_BRANCHES/#5-full-grid-branches","title":"5. Full Grid Branches","text":"<p>Controlled by: <code>Constants::STORE_FULL_GRID</code> in <code>Config.hh:222</code></p> <p>When <code>STORE_FULL_GRID = true</code>, additional branches store data for the entire detector pixel grid (not just the neighborhood). Vector size = <code>FullGridSide * FullGridSide</code>.</p>"},{"location":"ROOT_OUTPUT_BRANCHES/#common-full-grid-branches-always-saved-when-full-grid-enabled","title":"Common Full Grid Branches (Always Saved when full grid enabled)","text":"Branch Type Description <code>FullGridSide</code> Int Number of pixels per side <code>DistanceGrid</code> <code>vector&lt;Double&gt;</code> Distance from hit to each pixel <code>AlphaGrid</code> <code>vector&lt;Double&gt;</code> Solid angle for each pixel <code>PixelXGrid</code> <code>vector&lt;Double&gt;</code> X coordinates of all pixels <code>PixelYGrid</code> <code>vector&lt;Double&gt;</code> Y coordinates of all pixels"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-specific-full-grid-branches","title":"Mode-Specific Full Grid Branches","text":""},{"location":"ROOT_OUTPUT_BRANCHES/#mode-neighborhood","title":"Mode: <code>Neighborhood</code>","text":"Branch Description <code>FiGrid</code> Signal fractions (neighborhood denominator) <code>QiGrid</code> Induced charges <code>QnGrid</code> Charges after gain noise <code>QfGrid</code> Final charges"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-rowcol_1","title":"Mode: <code>RowCol</code>","text":"Branch Description <code>FiRowGrid</code> Row-denominator fractions <code>FiColGrid</code> Column-denominator fractions <code>QiRowGrid</code>, <code>QnRowGrid</code>, <code>QfRowGrid</code> Row-based charges <code>QiColGrid</code>, <code>QnColGrid</code>, <code>QfColGrid</code> Column-based charges"},{"location":"ROOT_OUTPUT_BRANCHES/#mode-chargeblock_1","title":"Mode: <code>ChargeBlock</code>","text":"Branch Description <code>FiBlockGrid</code> Block-denominator fractions <code>QiBlockGrid</code>, <code>QnBlockGrid</code>, <code>QfBlockGrid</code> Block-based charges"},{"location":"ROOT_OUTPUT_BRANCHES/#charge-calculation-physics","title":"Charge Calculation Physics","text":""},{"location":"ROOT_OUTPUT_BRANCHES/#signal-fraction-tornago-eq-4","title":"Signal Fraction (Tornago Eq. 4)","text":"<p><pre><code>F_i = w_i / \u03a3_n(w_n)\n</code></pre> where <code>w_i = \u03b1_i / ln(d_i/d_0)</code> is the weight for pixel i.</p>"},{"location":"ROOT_OUTPUT_BRANCHES/#denominator-options","title":"Denominator Options","text":"<ul> <li>Neighborhood: <code>\u03a3_n</code> over all pixels in the (2r+1)\u00d7(2r+1) neighborhood</li> <li>Row: <code>\u03a3_n</code> over pixels in the same row as pixel i</li> <li>Column: <code>\u03a3_n</code> over pixels in the same column as pixel i</li> <li>Block: <code>\u03a3_n</code> over the 4 pixels closest to the hit position</li> </ul>"},{"location":"ROOT_OUTPUT_BRANCHES/#charge-computation","title":"Charge Computation","text":"<pre><code>Q_induced = F_i \u00d7 Q_total\nQ_noisy = Q_induced \u00d7 (1 + gain_noise)\nQ_final = max(0, Q_noisy + additive_noise)\n</code></pre>"},{"location":"ROOT_OUTPUT_BRANCHES/#special-values","title":"Special Values","text":"Value Meaning <code>-999.0</code> Sentinel for out-of-bounds or invalid fraction <code>NaN</code> Uninitialized distance/alpha values <code>-1</code> Invalid pixel ID or index"},{"location":"ROOT_OUTPUT_BRANCHES/#how-to-change-mode","title":"How to Change Mode","text":"<p>Edit <code>Config.hh</code> line 197:</p> <pre><code>// For neighborhood mode (default):\ninline constexpr ECS::Config::DenominatorMode DENOMINATOR_MODE = ECS::Config::DenominatorMode::Neighborhood;\n\n// For row/column mode:\ninline constexpr ECS::Config::DenominatorMode DENOMINATOR_MODE = ECS::Config::DenominatorMode::RowCol;\n\n// For 4-pixel block mode:\ninline constexpr ECS::Config::DenominatorMode DENOMINATOR_MODE = ECS::Config::DenominatorMode::ChargeBlock;\n</code></pre> <p>Then rebuild the project.</p>"},{"location":"ROOT_OUTPUT_BRANCHES/#example-reading-the-root-file","title":"Example: Reading the ROOT File","text":"<pre><code>TFile* f = TFile::Open(\"epicChargeSharing.root\");\nTTree* tree = (TTree*)f-&gt;Get(\"tree\");\n\n// Scalar data\nDouble_t trueX, trueY, edep;\ntree-&gt;SetBranchAddress(\"TrueX\", &amp;trueX);\ntree-&gt;SetBranchAddress(\"TrueY\", &amp;trueY);\ntree-&gt;SetBranchAddress(\"Edep\", &amp;edep);\n\n// Vector data (for Neighborhood mode)\nstd::vector&lt;Double_t&gt;* Fi = nullptr;\nstd::vector&lt;Double_t&gt;* Qi = nullptr;\ntree-&gt;SetBranchAddress(\"Fi\", &amp;Fi);\ntree-&gt;SetBranchAddress(\"Qi\", &amp;Qi);\n\nfor (Long64_t i = 0; i &lt; tree-&gt;GetEntries(); i++) {\n    tree-&gt;GetEntry(i);\n    // Process event...\n}\n</code></pre>"},{"location":"ROOT_OUTPUT_BRANCHES/#metadata","title":"Metadata","text":"<p>Simulation parameters are stored as <code>TNamed</code> key-value objects in the ROOT file. This allows analysis scripts to access the exact configuration used for each run.</p>"},{"location":"ROOT_OUTPUT_BRANCHES/#metadata-fields","title":"Metadata Fields","text":"Key Type Description <code>MetadataSchemaVersion</code> String Schema version (currently \"2\") <code>GridPixelSize_mm</code> Double Pixel size in mm <code>GridPixelSpacing_mm</code> Double Pixel pitch/spacing in mm <code>GridPixelCornerOffset_mm</code> Double Offset from detector edge in mm <code>GridDetectorSize_mm</code> Double Full detector size in mm <code>GridNumBlocksPerSide</code> Int Number of pixels per side <code>FullGridSide</code> Int Full grid dimension (if enabled) <code>NeighborhoodRadius</code> Int Neighborhood radius (2 = 5x5) <code>ChargeSharingModel</code> String Position reconstruction model: <code>LogA</code>, <code>LinA</code>, or <code>DPC</code> <code>DenominatorMode</code> String Fraction denominator: <code>Neighborhood</code>, <code>RowCol</code>, or <code>ChargeBlock</code> <code>ChargeSharingLinearBeta_per_um</code> Double \u03b2 parameter for LinA/DPC models <code>ChargeSharingPitch_mm</code> Double Pixel pitch for charge sharing <code>ChargeSharingReferenceD0_microns</code> Double d\u2080 reference distance (Tornago Eq. 4) <code>IonizationEnergy_eV</code> Double Energy per e-h pair (3.6 eV) <code>Gain</code> Double AC-LGAD amplification factor <code>ElementaryCharge_C</code> Double Electron charge in Coulombs <code>NoisePixelGainSigmaMin</code> Double Minimum gain noise sigma <code>NoisePixelGainSigmaMax</code> Double Maximum gain noise sigma <code>NoiseElectronCount</code> Double Additive noise in electrons <code>ChargeSharingEmitDistanceAlpha</code> Bool Whether d_i/\u03b1_i are stored <code>ChargeSharingFullFractionsEnabled</code> Bool Whether full grid is stored <code>PostProcessFitGaus1DEnabled</code> Bool 1D Gaussian fit enabled <code>PostProcessFitGaus2DEnabled</code> Bool 2D Gaussian fit enabled"},{"location":"ROOT_OUTPUT_BRANCHES/#reading-metadata","title":"Reading Metadata","text":"<pre><code>TFile* f = TFile::Open(\"epicChargeSharing.root\");\n\n// Read a string metadata value\nTNamed* mode = (TNamed*)f-&gt;Get(\"DenominatorMode\");\nif (mode) {\n    std::cout &lt;&lt; \"Denominator Mode: \" &lt;&lt; mode-&gt;GetTitle() &lt;&lt; std::endl;\n}\n\n// Read a numeric value\nTNamed* d0 = (TNamed*)f-&gt;Get(\"ChargeSharingReferenceD0_microns\");\nif (d0) {\n    double d0_value = std::stod(d0-&gt;GetTitle());\n}\n</code></pre>"},{"location":"ROOT_OUTPUT_BRANCHES/#file-location","title":"File Location","text":"<p>Output file: <code>build/epicChargeSharing.root</code></p>"},{"location":"ROOT_UPGRADES_REPORT/","title":"ROOT Upgrades Research Report for epicChargeSharing","text":"<p>Date: December 2025 Current ROOT Usage: TTree, TFile, TFileMerger, Minuit2, TGraph2D, TGraphErrors, ROOT macros for fitting</p>"},{"location":"ROOT_UPGRADES_REPORT/#executive-summary","title":"Executive Summary","text":"<p>This report analyzes recent ROOT developments (2024-2025) that could improve the epicChargeSharing simulation's performance, maintainability, and capabilities. The most impactful upgrades are:</p> <ol> <li>RNTuple - 20-50% storage reduction, 1.5-2x faster I/O</li> <li>RDataFrame - Simplified analysis with automatic parallelization</li> <li>Minuit2 Improvements - Better memory handling and error management</li> <li>Implicit Multithreading - Parallel fitting and tree processing</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#1-rntuple-next-generation-data-storage","title":"1. RNTuple: Next-Generation Data Storage","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is","title":"What It Is","text":"<p>RNTuple is ROOT's successor to TTree, redesigned from scratch for modern computing. The on-disk binary format was finalized in ROOT 6.34 (November 2024) and is production-ready.</p>"},{"location":"ROOT_UPGRADES_REPORT/#current-state-in-epicchargesharing","title":"Current State in epicChargeSharing","text":"<p>The simulation uses <code>TTree</code> with the following structure: - Hits tree with ~40 branches - Scalar branches: <code>TrueX</code>, <code>TrueY</code>, <code>Edep</code>, <code>ReconX</code>, <code>ReconY</code>, etc. - Vector branches: <code>NeighborhoodPixelX</code>, <code>d_i</code>, <code>alpha_i</code>, <code>Fi</code>, <code>Qi</code>, etc. - Grid branches for full detector output</p>"},{"location":"ROOT_UPGRADES_REPORT/#improvements-if-implemented","title":"Improvements If Implemented","text":"Metric TTree RNTuple Improvement Storage Size Baseline 20-35% smaller Significant disk savings Read Throughput ~150 MB/s 500+ MB/s single core 3x faster analysis Write Performance Good Much better Faster simulation runs Multicore Scaling Limited Excellent (35 GB/s on 100+ cores) Better HPC utilization"},{"location":"ROOT_UPGRADES_REPORT/#key-features","title":"Key Features","text":"<ul> <li>Parallel Writing: <code>RNTupleParallelWriter</code> supports cluster staging for ordered output</li> <li>Direct I/O: Accesses peak NVMe performance</li> <li>Modern C++ Containers: Native support for <code>std::unordered_set</code>, <code>std::map</code>, <code>std::unordered_map</code></li> <li>Zero-Code Migration: RDataFrame auto-detects format</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-complexity","title":"Implementation Complexity","text":"<p>Medium - Requires updating <code>RootIO.cc</code> and <code>RootHelpers.cc</code>: <pre><code>// Instead of TTree\n#include &lt;ROOT/RNTupleModel.hxx&gt;\n#include &lt;ROOT/RNTupleWriter.hxx&gt;\n\nauto model = RNTupleModel::Create();\nmodel-&gt;MakeField&lt;double&gt;(\"TrueX\");\nmodel-&gt;MakeField&lt;std::vector&lt;double&gt;&gt;(\"Fi\");\n// ... etc\nauto writer = RNTupleWriter::Recreate(std::move(model), \"Hits\", \"output.root\");\n</code></pre></p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation","title":"Recommendation","text":"<p>HIGH PRIORITY - Adopt RNTuple for ROOT 6.36+ deployments. The 20-35% storage reduction is valuable for sweep analyses generating many files.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources","title":"Sources","text":"<ul> <li>RNTuple: Where are we now and what's next?</li> <li>ROOT's RNTuple I/O Subsystem: Path to Production</li> <li>First Release of the RNTuple On-Disk Format</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#2-rdataframe-modern-analysis-interface","title":"2. RDataFrame: Modern Analysis Interface","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is_1","title":"What It Is","text":"<p>RDataFrame is ROOT's high-level declarative interface for data analysis, providing automatic parallelization and lazy evaluation.</p>"},{"location":"ROOT_UPGRADES_REPORT/#current-state-in-epicchargesharing_1","title":"Current State in epicChargeSharing","text":"<p>Analysis currently uses: - Python <code>uproot</code> for file reading (<code>Fi_x.py</code>, <code>sigma_f_x.py</code>) - ROOT macros with manual <code>SetBranchAddress</code> loops (<code>FitGaussian1D.C</code>, <code>FitGaussian2D.C</code>)</p>"},{"location":"ROOT_UPGRADES_REPORT/#improvements-if-implemented_1","title":"Improvements If Implemented","text":"Feature Current Approach RDataFrame Benefit Parallelization Manual with <code>TFileMerger</code> Automatic with <code>EnableImplicitMT()</code> Simpler code, better scaling Memory Usage Full vectors in memory Lazy columnar access Lower memory footprint Code Complexity ~200 lines per macro ~20-30 lines More maintainable Type Safety Runtime errors Compile-time checks Fewer bugs"},{"location":"ROOT_UPGRADES_REPORT/#root-634-rdataframe-improvements","title":"ROOT 6.34 RDataFrame Improvements","text":"<ul> <li>Execution Order Guarantee: Operations now execute top-to-bottom</li> <li>Memory Optimization: Distributed RDataFrame memory drastically reduced</li> <li>Missing Data Handling: New <code>DefaultValueFor()</code> and <code>FilterAvailable()</code> APIs</li> <li>Type Conversion Control: <code>RSnapshotOptions::fVector2RVec</code> flag</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#example-transformation","title":"Example Transformation","text":"<p>Current manual approach in fitting macros: <pre><code>TFile* f = TFile::Open(filename);\nTTree* tree = (TTree*)f-&gt;Get(\"Hits\");\nstd::vector&lt;double&gt; *Fi = nullptr;\ntree-&gt;SetBranchAddress(\"Fi\", &amp;Fi);\nfor (Long64_t i = 0; i &lt; tree-&gt;GetEntries(); i++) {\n    tree-&gt;GetEntry(i);\n    // process...\n}\n</code></pre></p> <p>RDataFrame approach: <pre><code>ROOT::EnableImplicitMT();  // Automatic parallelization\nROOT::RDataFrame df(\"Hits\", filename);\nauto result = df.Filter(\"NeighborhoodSize &gt; 1\")\n               .Define(\"mean_Fi\", \"Mean(Fi)\")\n               .Histo1D(\"mean_Fi\");\n</code></pre></p>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-complexity_1","title":"Implementation Complexity","text":"<p>Low-Medium - Gradual migration possible: 1. Start with Python analysis scripts (already using uproot) 2. Migrate ROOT macros one at a time 3. Analysis code becomes ~80% shorter</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_1","title":"Recommendation","text":"<p>MEDIUM PRIORITY - Migrate analysis macros to RDataFrame. Immediate benefits for <code>FitGaussian1D.C</code> and <code>FitGaussian2D.C</code> with automatic parallelization.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_1","title":"Sources","text":"<ul> <li>ROOT RDataFrame Class Reference</li> <li>Distributed Analysis in Production with RDataFrame</li> <li>ROOT 6.32 Release Notes</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#3-minuit2-fitting-improvements","title":"3. Minuit2 Fitting Improvements","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is_2","title":"What It Is","text":"<p>Minuit2 is ROOT's primary minimization library, used for curve fitting and parameter optimization.</p>"},{"location":"ROOT_UPGRADES_REPORT/#current-state-in-epicchargesharing_2","title":"Current State in epicChargeSharing","text":"<p>The simulation uses Minuit2 extensively: - Minimizer: <code>Minuit2</code> with <code>Fumili2</code> algorithm - Fits: 1D and 2D Gaussian fits on charge fractions - Configuration: Custom distance-weighted error models - Files: <code>FitGaussian1D.C</code>, <code>FitGaussian2D.C</code></p>"},{"location":"ROOT_UPGRADES_REPORT/#root-634-minuit2-improvements","title":"ROOT 6.34 Minuit2 Improvements","text":"Feature Before After Impact Interface Arguments <code>std::vector&lt;double&gt; const&amp;</code> <code>std::span&lt;const double&gt;</code> No forced memory allocations Initial Covariance Not supported <code>AddCovariance()</code> method Better convergence MultiProcess Errors Silent failures Proper NaN handling Robust distributed fits ATLAS Compatibility Some fits failed Full support Enterprise-grade stability"},{"location":"ROOT_UPGRADES_REPORT/#specific-improvements-relevant-to-epicchargesharing","title":"Specific Improvements Relevant to epicChargeSharing","text":"<ol> <li>Memory Efficiency: The new <code>std::span</code> interface eliminates vector copies during fit iterations</li> <li>Initial Hessian Seeding: If you have prior knowledge of parameter correlations, you can now seed the minimizer:    <pre><code>ROOT::Minuit2::MnUserParameterState state;\n// ... set parameters ...\nstate.AddCovariance(priorCovariance);\n</code></pre></li> <li>Error Handling: Fits encountering NaN values now complete successfully instead of silently failing</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-complexity_2","title":"Implementation Complexity","text":"<p>Very Low - These improvements are automatic with ROOT 6.34+. No code changes required.</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_2","title":"Recommendation","text":"<p>HIGH PRIORITY - Upgrade to ROOT 6.34+ to get these improvements for free. Especially valuable for your distance-weighted error fitting which can produce edge-case NaN values.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_2","title":"Sources","text":"<ul> <li>ROOT 6.34 Release Notes</li> <li>Minuit2 Minimization Library</li> <li>New Developments in Minuit2 (CHEP 2023)</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#4-implicit-multithreading-imt","title":"4. Implicit Multithreading (IMT)","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is_3","title":"What It Is","text":"<p>ROOT's implicit multithreading automatically parallelizes operations like tree reading, histogram filling, and fitting.</p>"},{"location":"ROOT_UPGRADES_REPORT/#current-state-in-epicchargesharing_3","title":"Current State in epicChargeSharing","text":"<ul> <li>Geant4 multithreading for simulation (<code>G4MULTITHREADED</code>)</li> <li><code>TFileMerger</code> for combining worker outputs</li> <li><code>RootIOMutex()</code> for thread-safe I/O</li> <li>No IMT in analysis macros</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#components-that-benefit-from-imt","title":"Components That Benefit from IMT","text":"Component IMT Benefit Notes <code>TTree::GetEntry()</code> Parallel branch decompression Automatic <code>TTree::Fill()</code> Parallel branch compression Automatic <code>TH1::Fit()</code> Parallel objective evaluation Significant for your Gaussian fits RDataFrame Full parallel event loop Requires code migration"},{"location":"ROOT_UPGRADES_REPORT/#root-632-threading-improvements","title":"ROOT 6.32 Threading Improvements","text":"<ul> <li><code>TTreeIndex::Clone()</code> now uses memory copy instead of I/O (faster for RDataFrame)</li> <li><code>TH3D</code> atomic filling with C++20 (your code uses C++20!)</li> <li>Constant-time type matching (eliminated lock contention)</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#implementation","title":"Implementation","text":"<p>Add to your fitting macros: <pre><code>ROOT::EnableImplicitMT();  // Use all cores\n// or\nROOT::EnableImplicitMT(4);  // Use 4 threads\n\n// Your existing TH1::Fit() calls automatically parallelize\n</code></pre></p>"},{"location":"ROOT_UPGRADES_REPORT/#memory-consideration","title":"Memory Consideration","text":"<p>With IMT, each thread creates local histogram copies. For your 2D fits with <code>TGraph2DErrors</code>, memory usage scales with thread count. Monitor with large neighborhood grids.</p>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-complexity_3","title":"Implementation Complexity","text":"<p>Very Low - Single line addition to enable.</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_3","title":"Recommendation","text":"<p>HIGH PRIORITY - Add <code>ROOT::EnableImplicitMT()</code> to <code>FitGaussian1D.C</code> and <code>FitGaussian2D.C</code>. Your complex 2D Gaussian fits with distance-weighted errors will see significant speedup.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_3","title":"Sources","text":"<ul> <li>ROOT Multi-threading Manual</li> <li>Parallelism with ROOT</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#5-roofit-vectorized-backend","title":"5. RooFit Vectorized Backend","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is_4","title":"What It Is","text":"<p>ROOT 6.32 made the vectorizing CPU evaluation backend the default for RooFit likelihood calculations.</p>"},{"location":"ROOT_UPGRADES_REPORT/#relevance-to-epicchargesharing","title":"Relevance to epicChargeSharing","text":"<p>Currently not using RooFit, but if you expand to: - Complex likelihood fits - Systematic uncertainty propagation - Statistical model building</p>"},{"location":"ROOT_UPGRADES_REPORT/#improvement","title":"Improvement","text":"<p>Up to 10x faster likelihood minimization on a single CPU core.</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_4","title":"Recommendation","text":"<p>LOW PRIORITY - Only relevant if expanding to statistical modeling beyond current Gaussian fits.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_4","title":"Sources","text":"<ul> <li>ROOT 6.32 Release Notes</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#6-graphics-and-visualization-improvements","title":"6. Graphics and Visualization Improvements","text":""},{"location":"ROOT_UPGRADES_REPORT/#root-634-graphics-updates","title":"ROOT 6.34 Graphics Updates","text":"<ul> <li>Web Canvas: Batch image production with headless browsers</li> <li>Multi-page PDFs: <code>canvas-&gt;SaveAs(\"file.pdf[\")</code> for multi-page documents</li> <li>Colorblind-Friendly Palettes: Three new schemes (Petroff research)</li> <li>REve: SDF font rendering, overlay system</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#root-636-uhi-unified-histogram-interface","title":"ROOT 6.36 UHI (Unified Histogram Interface)","text":"<ul> <li>Python-style histogram slicing and indexing</li> <li>Interoperability with other UHI-compatible libraries</li> <li>Enhanced plotting protocols</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#relevance-to-epicchargesharing_1","title":"Relevance to epicChargeSharing","text":"<p>Your plotting macros (<code>plotChargeNeighborhood.C</code>, <code>plotHitsOnGrid.C</code>, etc.) could benefit from: 1. Colorblind-friendly palettes for publications 2. Multi-page PDF export for parameter sweeps 3. Better web visualization for interactive analysis</p>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-complexity_4","title":"Implementation Complexity","text":"<p>Low - Mostly cosmetic improvements, easy to adopt.</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_5","title":"Recommendation","text":"<p>MEDIUM PRIORITY - Adopt colorblind palettes for publication figures.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_5","title":"Sources","text":"<ul> <li>ROOT 6.34 Release Notes</li> <li>ROOT's UHI</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#7-machine-learning-integration","title":"7. Machine Learning Integration","text":""},{"location":"ROOT_UPGRADES_REPORT/#what-it-is_5","title":"What It Is","text":"<p>ROOT 6.34 improved the ability to feed ROOT data directly to ML training pipelines.</p>"},{"location":"ROOT_UPGRADES_REPORT/#features","title":"Features","text":"<ul> <li>Train on datasets larger than machine memory</li> <li>RDataFrame \u2192 ML tool pipeline</li> <li>Lazy batch loading for training</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#relevance-to-epicchargesharing_2","title":"Relevance to epicChargeSharing","text":"<p>If you explore ML-based reconstruction: - Train neural networks on charge fraction patterns - Use RDataFrame to preprocess simulation data - Stream data to PyTorch/TensorFlow</p>"},{"location":"ROOT_UPGRADES_REPORT/#recommendation_6","title":"Recommendation","text":"<p>LOW PRIORITY - Only relevant if exploring ML reconstruction methods.</p>"},{"location":"ROOT_UPGRADES_REPORT/#sources_6","title":"Sources","text":"<ul> <li>ROOT 6.34 Release Notes</li> </ul>"},{"location":"ROOT_UPGRADES_REPORT/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"ROOT_UPGRADES_REPORT/#phase-1-immediate-no-code-changes","title":"Phase 1: Immediate (No Code Changes)","text":"<ol> <li>Upgrade to ROOT 6.34+ - Get Minuit2 improvements automatically</li> <li>Verify C++20 atomic TH3 - Already using C++20</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#phase-2-quick-wins-minimal-changes","title":"Phase 2: Quick Wins (Minimal Changes)","text":"<ol> <li>Enable IMT in fitting macros - Add single line</li> <li>Adopt colorblind palettes - Update plotting code</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#phase-3-medium-term-moderate-refactoring","title":"Phase 3: Medium-Term (Moderate Refactoring)","text":"<ol> <li>Migrate analysis to RDataFrame - Rewrite fitting macros</li> <li>Adopt RNTuple for output - Update RootIO.cc</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#phase-4-long-term-major-refactoring","title":"Phase 4: Long-Term (Major Refactoring)","text":"<ol> <li>Distributed RDataFrame - For farm sweep analysis</li> <li>ML integration - If exploring neural reconstruction</li> </ol>"},{"location":"ROOT_UPGRADES_REPORT/#version-compatibility-matrix","title":"Version Compatibility Matrix","text":"ROOT Version Release Date RNTuple IMT Minuit2 span Status 6.30 Nov 2023 Experimental Yes No Legacy 6.32 May 2024 Experimental Enhanced No LTS 6.34 Nov 2024 Production Enhanced Yes Current 6.36 May 2025 Production Enhanced Yes Recommended"},{"location":"ROOT_UPGRADES_REPORT/#summary-of-expected-improvements","title":"Summary of Expected Improvements","text":"Upgrade Effort Storage Speed Maintainability ROOT 6.34+ None - +10-20% (fitting) + Enable IMT Very Low - +50-200% (fitting) + RDataFrame Medium - +50-100% (analysis) +++ RNTuple Medium -20-35% +150-200% (I/O) ++ Colorblind palettes Low - - +"},{"location":"ROOT_UPGRADES_REPORT/#conclusion","title":"Conclusion","text":"<p>The most impactful upgrades for epicChargeSharing are:</p> <ol> <li>Enable Implicit Multithreading - Immediate speedup for Gaussian fitting with one line of code</li> <li>Upgrade to ROOT 6.34+ - Free Minuit2 improvements for better fit stability</li> <li>Adopt RNTuple - 20-35% storage reduction critical for parameter sweep studies</li> <li>Migrate to RDataFrame - Cleaner, more maintainable analysis code with automatic parallelization</li> </ol> <p>These improvements align well with your current workflow of running parameter sweeps and analyzing charge sharing distributions across many configurations.</p>"},{"location":"analysis-guide/","title":"Analysis Guide","text":"<p>This document describes how to analyze simulation output from epicChargeSharing, including built-in tools, Python scripts, and ROOT macros.</p>"},{"location":"analysis-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Output Overview</li> <li>Quick Analysis</li> <li>Python Analysis Scripts</li> <li>ROOT Macros</li> <li>Position Sweep Studies</li> <li>Custom Analysis</li> <li>Visualization</li> </ul>"},{"location":"analysis-guide/#output-overview","title":"Output Overview","text":""},{"location":"analysis-guide/#root-file-structure","title":"ROOT File Structure","text":"<p>The simulation produces <code>epicChargeSharing.root</code> containing:</p> <pre><code>epicChargeSharing.root\n\u251c\u2500\u2500 tree (TTree)                    # Event-by-event data\n\u2502   \u251c\u2500\u2500 TrueX, TrueY, TrueZ        # True hit position\n\u2502   \u251c\u2500\u2500 PixelX, PixelY             # Nearest pixel center\n\u2502   \u251c\u2500\u2500 ReconX, ReconY             # Reconstructed position\n\u2502   \u251c\u2500\u2500 Edep                       # Energy deposit\n\u2502   \u251c\u2500\u2500 ReconTrueDeltaX/Y          # Reconstruction residuals\n\u2502   \u251c\u2500\u2500 Fi, Qi, Qn, Qf             # Charge fractions/charges\n\u2502   \u251c\u2500\u2500 d_i, alpha_i               # Distance/angle arrays\n\u2502   \u2514\u2500\u2500 ...                        # See ROOT_OUTPUT_BRANCHES.md\n\u2502\n\u2514\u2500\u2500 Metadata (TNamed)              # Simulation parameters\n    \u251c\u2500\u2500 ChargeSharingModel\n    \u251c\u2500\u2500 DenominatorMode\n    \u251c\u2500\u2500 Gain\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"analysis-guide/#key-branches-for-analysis","title":"Key Branches for Analysis","text":"Branch Type Description <code>TrueX</code>, <code>TrueY</code> Double True particle position (mm) <code>ReconX</code>, <code>ReconY</code> Double Reconstructed position (mm) <code>ReconTrueDeltaX</code> Double X residual: ReconX - TrueX (mm) <code>ReconTrueDeltaY</code> Double Y residual: ReconY - TrueY (mm) <code>Fi</code> vector Signal fractions per pixel <code>Qi</code> vector Induced charge per pixel <code>d_i</code> vector Distance to each pixel (mm)"},{"location":"analysis-guide/#quick-analysis","title":"Quick Analysis","text":""},{"location":"analysis-guide/#using-root-interactively","title":"Using ROOT Interactively","text":"<pre><code>root -l epicChargeSharing.root\n</code></pre> <pre><code>// List branches\ntree-&gt;Print();\n\n// Plot reconstruction residuals\ntree-&gt;Draw(\"ReconTrueDeltaX\");\ntree-&gt;Draw(\"ReconTrueDeltaY\");\n\n// 2D residual map\ntree-&gt;Draw(\"ReconTrueDeltaY:ReconTrueDeltaX\", \"\", \"COLZ\");\n\n// Reconstruction residual vs true position\ntree-&gt;Draw(\"ReconTrueDeltaX:TrueX\", \"\", \"COLZ\");\n\n// Central pixel charge fraction\ntree-&gt;Draw(\"Fi[12]\");  // Index 12 = center of 5x5 grid\n\n// Resolution histogram with Gaussian fit\nTH1F* h = new TH1F(\"h\", \"X Resolution\", 100, -0.1, 0.1);\ntree-&gt;Draw(\"ReconTrueDeltaX&gt;&gt;h\");\nh-&gt;Fit(\"gaus\");\n</code></pre>"},{"location":"analysis-guide/#using-pyroot","title":"Using PyROOT","text":"<pre><code>import ROOT\n\nf = ROOT.TFile.Open(\"epicChargeSharing.root\")\ntree = f.Get(\"tree\")\n\n# Create histogram\nh = ROOT.TH1F(\"res_x\", \"X Resolution;#DeltaX (mm);Events\", 100, -0.1, 0.1)\ntree.Draw(\"ReconTrueDeltaX&gt;&gt;res_x\")\n\n# Fit Gaussian\nh.Fit(\"gaus\")\nfit = h.GetFunction(\"gaus\")\nsigma = fit.GetParameter(2)\nprint(f\"Resolution: {sigma*1000:.1f} um\")\n\n# Save plot\nc = ROOT.TCanvas()\nh.Draw()\nc.SaveAs(\"resolution.png\")\n</code></pre>"},{"location":"analysis-guide/#using-uproot-pure-python","title":"Using uproot (Pure Python)","text":"<pre><code>import uproot\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Open file\nf = uproot.open(\"epicChargeSharing.root\")\ntree = f[\"tree\"]\n\n# Read branches\ntrue_x = tree[\"TrueX\"].array(library=\"np\")\nrecon_x = tree[\"ReconX\"].array(library=\"np\")\ndelta_x = recon_x - true_x\n\n# Plot histogram\nplt.hist(delta_x, bins=100, range=(-0.1, 0.1))\nplt.xlabel(\"\u0394X (mm)\")\nplt.ylabel(\"Events\")\nplt.savefig(\"resolution.png\")\n</code></pre>"},{"location":"analysis-guide/#python-analysis-scripts","title":"Python Analysis Scripts","text":""},{"location":"analysis-guide/#location","title":"Location","text":"<p>Analysis scripts are in the <code>farm/</code> directory:</p> <pre><code>farm/\n\u251c\u2500\u2500 Fi_x.py              # Charge fraction vs position\n\u251c\u2500\u2500 sigma_f_x.py         # Resolution vs position\n\u251c\u2500\u2500 sweep_x.py           # Generate position sweeps\n\u251c\u2500\u2500 sweep_analysis.py    # Batch sweep processing\n\u2514\u2500\u2500 run_gaussian_fits.py # Execute fit macros\n</code></pre>"},{"location":"analysis-guide/#dependencies","title":"Dependencies","text":"<pre><code>pip install uproot awkward numpy pandas matplotlib scipy openpyxl\n</code></pre>"},{"location":"analysis-guide/#fi_xpy-charge-fraction-analysis","title":"Fi_x.py - Charge Fraction Analysis","text":"<p>Analyzes how charge fractions vary with particle position.</p> <p>Usage: <pre><code>python3 farm/Fi_x.py --input-dir /path/to/sweep_files\n</code></pre></p> <p>Options: | Option | Description | |--------|-------------| | <code>--input-dir</code> | Directory with sweep ROOT files | | <code>--input-dir2</code> | Second directory for comparison | | <code>--output-dir</code> | Output directory for plots | | <code>--pixel-id</code> | Specific pixel ID to track |</p> <p>Outputs: - Excel workbook with mean fractions per position - PNG plots of F_i vs x position - Per-file histogram distributions (optional)</p>"},{"location":"analysis-guide/#sigma_f_xpy-resolution-analysis","title":"sigma_f_x.py - Resolution Analysis","text":"<p>Fits Gaussians to reconstruction residuals and extracts resolution.</p> <p>Usage: <pre><code>python3 farm/sigma_f_x.py --input-dir /path/to/sweep_files\n</code></pre></p> <p>Outputs: - Excel workbook: x position, \u03c3, \u03c3_error, std dev - PNG plots with Gaussian fits - Summary resolution vs position plot</p>"},{"location":"analysis-guide/#sweep_xpy-position-sweep-generation","title":"sweep_x.py - Position Sweep Generation","text":"<p>Generates macro files for systematic position scans.</p> <p>Usage: <pre><code>python3 farm/sweep_x.py --start -250 --end 250 --step 25 --output-dir sweeps\n</code></pre></p> <p>Options: | Option | Default | Description | |--------|---------|-------------| | <code>--start</code> | -250 | Start position (\u00b5m) | | <code>--end</code> | 250 | End position (\u00b5m) | | <code>--step</code> | 25 | Step size (\u00b5m) | | <code>--events</code> | 50000 | Events per position |</p>"},{"location":"analysis-guide/#root-macros","title":"ROOT Macros","text":""},{"location":"analysis-guide/#location_1","title":"Location","text":"<p>ROOT macros are in <code>src/</code> and <code>proc/</code>:</p> <pre><code>src/\n\u251c\u2500\u2500 FitGaussian1D.C     # 1D Gaussian fitting\n\u2514\u2500\u2500 FitGaussian2D.C     # 2D Gaussian fitting\n\nproc/\n\u251c\u2500\u2500 fit/                # Fitting macros\n\u2514\u2500\u2500 grid/               # Visualization macros\n    \u251c\u2500\u2500 plotChargeNeighborhood.C\n    \u251c\u2500\u2500 plotHitsOnGrid.C\n    \u2514\u2500\u2500 plotPixeldiscretization.C\n</code></pre>"},{"location":"analysis-guide/#fitgaussian1dc","title":"FitGaussian1D.C","text":"<p>Fits 1D Gaussians to reconstruction residuals.</p> <p>Usage: <pre><code>root -l 'src/FitGaussian1D.C(\"epicChargeSharing.root\")'\n</code></pre></p> <p>Features: - Fits ReconTrueDeltaX and ReconTrueDeltaY - Outputs fit parameters (mean, sigma, error) - Saves fit plots as PNG</p>"},{"location":"analysis-guide/#fitgaussian2dc","title":"FitGaussian2D.C","text":"<p>Performs 2D Gaussian fitting to the residual distribution.</p> <p>Usage: <pre><code>root -l 'src/FitGaussian2D.C(\"epicChargeSharing.root\")'\n</code></pre></p>"},{"location":"analysis-guide/#plotchargeneighborhoodc","title":"plotChargeNeighborhood.C","text":"<p>Visualizes charge distribution in the neighborhood grid.</p> <p>Usage: <pre><code>root -l 'proc/grid/plotChargeNeighborhood.C(\"epicChargeSharing.root\")'\n</code></pre></p> <p>Output: Heatmap of charge fractions across the 5\u00d75 neighborhood.</p>"},{"location":"analysis-guide/#plothitsongridc","title":"plotHitsOnGrid.C","text":"<p>Plots hit positions overlaid on the pixel grid.</p> <p>Usage: <pre><code>root -l 'proc/grid/plotHitsOnGrid.C(\"epicChargeSharing.root\")'\n</code></pre></p>"},{"location":"analysis-guide/#position-sweep-studies","title":"Position Sweep Studies","text":""},{"location":"analysis-guide/#purpose","title":"Purpose","text":"<p>Position sweeps vary the particle gun position systematically to study: - Resolution vs position within a pixel - Charge sharing patterns - Edge effects</p>"},{"location":"analysis-guide/#workflow","title":"Workflow","text":"<ol> <li> <p>Generate sweep macros:    <pre><code>python3 farm/sweep_x.py --start -250 --end 250 --step 25\n</code></pre></p> </li> <li> <p>Run simulations (can be parallelized):    <pre><code>for mac in sweeps/*.mac; do\n    ./epicChargeSharing -m $mac &amp;\ndone\nwait\n</code></pre></p> </li> <li> <p>Analyze results:    <pre><code>python3 farm/sigma_f_x.py --input-dir sweeps/\npython3 farm/Fi_x.py --input-dir sweeps/\n</code></pre></p> </li> </ol>"},{"location":"analysis-guide/#batch-processing","title":"Batch Processing","text":"<p>For large sweeps on a computing cluster:</p> <pre><code># Generate job scripts\npython3 farm/sweep_analysis.py --mode generate --config sweep_config.yaml\n\n# Submit jobs\n./submit_jobs.sh\n\n# Collect results\npython3 farm/sweep_analysis.py --mode collect --input-dir results/\n</code></pre>"},{"location":"analysis-guide/#custom-analysis","title":"Custom Analysis","text":""},{"location":"analysis-guide/#reading-vector-branches","title":"Reading Vector Branches","text":"<pre><code>import uproot\nimport awkward as ak\n\nf = uproot.open(\"epicChargeSharing.root\")\ntree = f[\"tree\"]\n\n# Read vector branches (variable-length arrays)\nFi = tree[\"Fi\"].array()  # Returns awkward array\nd_i = tree[\"d_i\"].array()\n\n# Convert to numpy for specific event\nevent_0_fractions = ak.to_numpy(Fi[0])\n\n# Filter valid fractions\nvalid = Fi[Fi &gt; -900]  # Remove sentinel values\n</code></pre>"},{"location":"analysis-guide/#accessing-metadata","title":"Accessing Metadata","text":"<pre><code>import uproot\n\nf = uproot.open(\"epicChargeSharing.root\")\n\n# List all objects\nprint(f.keys())\n\n# Read metadata\nmodel = f[\"ChargeSharingModel\"]\nprint(f\"Model: {model}\")\n\ngain = f[\"Gain\"]\nprint(f\"Gain: {gain}\")\n</code></pre> <pre><code>// In ROOT\nTFile* f = TFile::Open(\"epicChargeSharing.root\");\nTNamed* model = (TNamed*)f-&gt;Get(\"ChargeSharingModel\");\ncout &lt;&lt; \"Model: \" &lt;&lt; model-&gt;GetTitle() &lt;&lt; endl;\n</code></pre>"},{"location":"analysis-guide/#computing-additional-quantities","title":"Computing Additional Quantities","text":"<pre><code>import uproot\nimport numpy as np\n\nf = uproot.open(\"epicChargeSharing.root\")\ntree = f[\"tree\"]\n\n# Read data\ntrue_x = tree[\"TrueX\"].array(library=\"np\")\ntrue_y = tree[\"TrueY\"].array(library=\"np\")\nrecon_x = tree[\"ReconX\"].array(library=\"np\")\nrecon_y = tree[\"ReconY\"].array(library=\"np\")\n\n# Compute 2D residual distance\ndelta_r = np.sqrt((recon_x - true_x)**2 + (recon_y - true_y)**2)\n\n# Compute resolution (RMS)\nresolution_x = np.std(recon_x - true_x)\nresolution_y = np.std(recon_y - true_y)\nresolution_r = np.std(delta_r)\n\nprint(f\"\u03c3_x = {resolution_x*1000:.1f} \u00b5m\")\nprint(f\"\u03c3_y = {resolution_y*1000:.1f} \u00b5m\")\nprint(f\"\u03c3_r = {resolution_r*1000:.1f} \u00b5m\")\n</code></pre>"},{"location":"analysis-guide/#selecting-events","title":"Selecting Events","text":"<pre><code>import uproot\nimport numpy as np\n\nf = uproot.open(\"epicChargeSharing.root\")\ntree = f[\"tree\"]\n\n# Read classification\nis_pixel_hit = tree[\"isPixelHit\"].array(library=\"np\")\nedep = tree[\"Edep\"].array(library=\"np\")\n\n# Select pixel hits only\ndelta_x = tree[\"ReconTrueDeltaX\"].array(library=\"np\")\npixel_hits = delta_x[is_pixel_hit]\n\n# Select high-energy events\nhigh_e = delta_x[edep &gt; 5.0]  # E &gt; 5 MeV\n</code></pre>"},{"location":"analysis-guide/#visualization","title":"Visualization","text":""},{"location":"analysis-guide/#charge-distribution-heatmap","title":"Charge Distribution Heatmap","text":"<pre><code>import uproot\nimport awkward as ak\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nf = uproot.open(\"epicChargeSharing.root\")\ntree = f[\"tree\"]\n\n# Read charge fractions (5x5 = 25 values per event)\nFi = tree[\"Fi\"].array()\n\n# Average over all events\nFi_mean = ak.mean(Fi, axis=0)\nFi_2d = ak.to_numpy(Fi_mean).reshape(5, 5)\n\n# Plot heatmap\nfig, ax = plt.subplots(figsize=(8, 6))\nim = ax.imshow(Fi_2d, cmap='hot', origin='lower')\nax.set_xlabel(\"Column\")\nax.set_ylabel(\"Row\")\nax.set_title(\"Mean Charge Fraction Distribution\")\nplt.colorbar(im, label=\"Fraction\")\nplt.savefig(\"charge_heatmap.png\")\n</code></pre>"},{"location":"analysis-guide/#resolution-vs-position","title":"Resolution vs Position","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# After running sweep analysis\npositions_um = [...]  # X positions in \u00b5m\nresolutions_um = [...]  # Fitted \u03c3 in \u00b5m\nerrors_um = [...]  # Fit errors\n\nfig, ax = plt.subplots(figsize=(10, 6))\nax.errorbar(positions_um, resolutions_um, yerr=errors_um,\n            fmt='o', capsize=3)\nax.set_xlabel(\"X Position (\u00b5m)\")\nax.set_ylabel(\"Resolution \u03c3 (\u00b5m)\")\nax.set_title(\"Position Resolution vs Hit Position\")\nax.grid(True, alpha=0.3)\nplt.savefig(\"resolution_vs_position.png\")\n</code></pre>"},{"location":"analysis-guide/#pixel-grid-visualization","title":"Pixel Grid Visualization","text":"<pre><code>import matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport numpy as np\n\n# Detector parameters\npitch = 0.5  # mm\npixel_size = 0.1  # mm\nn_pixels = 5\n\nfig, ax = plt.subplots(figsize=(8, 8))\n\n# Draw pixel grid\nfor i in range(n_pixels):\n    for j in range(n_pixels):\n        x = i * pitch\n        y = j * pitch\n        rect = patches.Rectangle(\n            (x - pixel_size/2, y - pixel_size/2),\n            pixel_size, pixel_size,\n            linewidth=1, edgecolor='blue', facecolor='lightblue'\n        )\n        ax.add_patch(rect)\n\n# Add hit position\nax.plot(1.0, 1.0, 'r*', markersize=15, label='Hit')\n\nax.set_xlim(-0.3, 2.3)\nax.set_ylim(-0.3, 2.3)\nax.set_aspect('equal')\nax.set_xlabel(\"X (mm)\")\nax.set_ylabel(\"Y (mm)\")\nax.legend()\nplt.savefig(\"pixel_grid.png\")\n</code></pre>"},{"location":"analysis-guide/#analysis-recipes","title":"Analysis Recipes","text":""},{"location":"analysis-guide/#recipe-1-basic-resolution-study","title":"Recipe 1: Basic Resolution Study","text":"<pre><code># 1. Run simulation\n./epicChargeSharing -m macros/run.mac\n\n# 2. Quick resolution check\nroot -l -e '\nTFile f(\"epicChargeSharing.root\");\nTTree* t = (TTree*)f.Get(\"tree\");\nt-&gt;Draw(\"ReconTrueDeltaX&gt;&gt;h(100,-0.1,0.1)\");\nh-&gt;Fit(\"gaus\");\n'\n</code></pre>"},{"location":"analysis-guide/#recipe-2-position-dependent-resolution","title":"Recipe 2: Position-Dependent Resolution","text":"<pre><code># 1. Generate position sweep\npython3 farm/sweep_x.py --start -250 --end 250 --step 25 --output sweeps/\n\n# 2. Run all positions\nfor mac in sweeps/*.mac; do ./epicChargeSharing -m $mac; done\n\n# 3. Analyze\npython3 farm/sigma_f_x.py --input-dir sweeps/\n</code></pre>"},{"location":"analysis-guide/#recipe-3-charge-sharing-pattern","title":"Recipe 3: Charge Sharing Pattern","text":"<pre><code># 1. Run at fixed position\n./epicChargeSharing -m macros/run.mac\n\n# 2. Plot neighborhood\nroot -l 'proc/grid/plotChargeNeighborhood.C(\"epicChargeSharing.root\")'\n\n# 3. Export data\npython3 -c \"\nimport uproot\nimport awkward as ak\nf = uproot.open('epicChargeSharing.root')\nFi = f['tree']['Fi'].array()\nprint('Mean fractions:', ak.mean(Fi, axis=0))\n\"\n</code></pre>"},{"location":"analysis-guide/#recipe-4-comparing-reconstruction-methods","title":"Recipe 4: Comparing Reconstruction Methods","text":"<pre><code># 1. Run with LogA (edit Config.hh, rebuild)\n./epicChargeSharing -m macros/run.mac\nmv epicChargeSharing.root logA.root\n\n# 2. Run with DPC (edit Config.hh, rebuild)\n./epicChargeSharing -m macros/run.mac\nmv epicChargeSharing.root dpc.root\n\n# 3. Compare\npython3 -c \"\nimport uproot\nimport numpy as np\n\nfor fname in ['logA.root', 'dpc.root']:\n    f = uproot.open(fname)\n    dx = f['tree']['ReconTrueDeltaX'].array(library='np')\n    print(f'{fname}: \u03c3 = {np.std(dx)*1000:.1f} \u00b5m')\n\"\n</code></pre>"},{"location":"analysis-guide/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Check metadata first: Verify simulation parameters before analysis</li> <li>Filter invalid values: Use <code>Fi &gt; -900</code> to exclude sentinel values</li> <li>Use uproot for large files: More memory-efficient than PyROOT</li> <li>Parallelize sweeps: Run multiple positions simultaneously</li> <li>Save intermediate results: Export to CSV/Excel for later analysis</li> <li>Document analysis parameters: Record bin sizes, cuts, fit ranges</li> </ol>"},{"location":"architecture/","title":"Architecture","text":"<p>This document describes the system architecture, component design, and data flow of the epicChargeSharing simulation.</p>"},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>System Architecture</li> <li>Component Descriptions</li> <li>Data Flow</li> <li>Threading Model</li> <li>Namespace Organization</li> </ul>"},{"location":"architecture/#overview","title":"Overview","text":"<p>epicChargeSharing follows the standard GEANT4 extended example architecture with custom extensions for AC-LGAD charge sharing simulation. The system is organized into:</p> <ol> <li>Simulation Core: GEANT4 user action classes</li> <li>Charge Calculation: Physics-based charge distribution algorithms</li> <li>I/O Layer: ROOT file output and metadata management</li> <li>Configuration: Compile-time and runtime parameters</li> </ol>"},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502              epicChargeSharing.cc           \u2502\n                    \u2502                 (Main Entry)                \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                            \u2502                            \u2502\n         \u25bc                            \u25bc                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 DetectorConstr. \u2502      \u2502   ActionInitializ.  \u2502      \u2502   PhysicsList   \u2502\n\u2502   (Geometry)    \u2502      \u2502  (Action Factory)   \u2502      \u2502  (EM Physics)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                          \u2502                          \u2502\n         \u25bc                          \u25bc                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PrimaryGenerator\u2502      \u2502    RunAction    \u2502      \u2502   EventAction   \u2502\n\u2502 (Particle Gun)  \u2502      \u2502 (ROOT I/O, Run) \u2502      \u2502 (Event Process) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                           \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502                                             \u2502\n                                    \u25bc                                             \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 ChargeSharingCalc.  \u2502                      \u2502  SteppingAction \u2502\n                         \u2502 (Core Algorithm)    \u2502                      \u2502 (Track Steps)   \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#component-descriptions","title":"Component Descriptions","text":""},{"location":"architecture/#detectorconstruction","title":"DetectorConstruction","text":"<p>File: <code>include/DetectorConstruction.hh</code>, <code>src/DetectorConstruction.cc</code></p> <p>Builds the physical detector geometry:</p> Element Dimensions Material World Volume 5 cm cube Air Silicon Detector 30\u00d730\u00d70.05 mm Silicon Pixel Pads 0.1\u00d70.1\u00d70.001 mm Aluminum <p>Key Features: - Configurable pixel grid geometry - Per-pixel gain noise assignment - Pixel finder for nearest-pixel lookup - G4Messenger for runtime geometry changes</p> <p>Configuration Interface: <pre><code>/ecs/detector/pixelSize &lt;value&gt; &lt;unit&gt;\n/ecs/detector/pixelPitch &lt;value&gt; &lt;unit&gt;\n/ecs/detector/pixelCornerOffset &lt;value&gt; &lt;unit&gt;\n</code></pre></p>"},{"location":"architecture/#chargesharingcalculator","title":"ChargeSharingCalculator","text":"<p>File: <code>include/ChargeSharingCalculator.hh</code>, <code>src/ChargeSharingCalculator.cc</code></p> <p>Core computation engine implementing the Tornago et al. charge sharing model.</p> <p>Computation Steps: 1. Find nearest pixel to hit position 2. Define (2r+1)\u00d7(2r+1) neighborhood grid 3. Compute charge fractions F_i for each pixel 4. Apply noise models (gain + electronic) 5. Optionally compute full detector grid fractions</p> <p>Key Data Structures:</p> <pre><code>struct PixelGridGeometry {\n    G4int nRows, nCols;      // Grid dimensions\n    G4double pitchX, pitchY; // Pixel spacing\n    G4double x0, y0;         // Grid origin\n};\n\nstruct HitInfo {\n    G4double trueX, trueY, trueZ;  // True position\n    G4int pixRow, pixCol;           // Nearest pixel indices\n    G4double pixCenterX, pixCenterY;// Pixel center\n};\n\nstruct ChargeMatrixSet {\n    Grid2D&lt;G4double&gt; signalFraction;     // F_i\n    Grid2D&lt;G4double&gt; signalFractionRow;  // Row-normalized\n    Grid2D&lt;G4double&gt; signalFractionCol;  // Col-normalized\n    Grid2D&lt;G4double&gt; signalFractionBlock;// Block-normalized\n    // + corresponding charge grids\n};\n</code></pre> <p>Signal Models:</p> Model Formula Use Case LogA <code>w_i = \u03b1_i / ln(d_i/d\u2080)</code> Standard charge sharing LinA <code>w_i = \u03b1_i \u00d7 exp(-\u03b2 \u00d7 d_i)</code> Linear attenuation"},{"location":"architecture/#eventaction","title":"EventAction","text":"<p>File: <code>include/EventAction.hh</code>, <code>src/EventAction.cc</code></p> <p>Per-event processing and data collection:</p> <p>Workflow: <pre><code>BeginOfEventAction()\n    \u2514\u2500\u2500 Reset accumulators\n\n[GEANT4 tracking loop]\n    \u2514\u2500\u2500 SteppingAction collects energy deposits\n\nEndOfEventAction()\n    \u251c\u2500\u2500 Determine hit position\n    \u251c\u2500\u2500 Call ChargeSharingCalculator::Compute()\n    \u251c\u2500\u2500 Perform position reconstruction (LogA/LinA/DPC)\n    \u2514\u2500\u2500 Fill ROOT tree via RunAction\n</code></pre></p> <p>Position Reconstruction Methods:</p> Method Algorithm LogA Chi-square fit to logarithmic model LinA Chi-square fit to linear model DPC Direct calculation: <code>pos = centroid + K \u00d7 charge_ratio</code>"},{"location":"architecture/#runaction","title":"RunAction","text":"<p>File: <code>include/RunAction.hh</code>, <code>src/RunAction.cc</code></p> <p>Run lifecycle and ROOT I/O management:</p> <p>Responsibilities: - ROOT file creation and TTree setup - Branch configuration (scalar, vector, classification) - Worker thread synchronization (multithreaded mode) - Worker file merging after run completion - Metadata publishing - Post-processing macro invocation</p> <p>Thread Safety: - Master thread creates output file - Worker threads write to separate files - Files merged at EndOfRunAction</p>"},{"location":"architecture/#primarygenerator","title":"PrimaryGenerator","text":"<p>File: <code>include/PrimaryGenerator.hh</code>, <code>src/PrimaryGenerator.cc</code></p> <p>Particle gun configuration:</p> <p>Modes: | Mode | Description | |------|-------------| | Fixed | Particles at specified (x,y) coordinates | | Random | Uniform sampling within detector bounds |</p> <p>Smart Margins: Automatically computes safe margins from edges based on neighborhood radius.</p> <p>G4Messenger Commands: <pre><code>/ecs/gun/fixedPosition &lt;bool&gt;\n/ecs/gun/fixedX &lt;value&gt;\n/ecs/gun/fixedY &lt;value&gt;\n</code></pre></p>"},{"location":"architecture/#physicslist","title":"PhysicsList","text":"<p>File: <code>include/PhysicsList.hh</code>, <code>src/PhysicsList.cc</code></p> <p>Physics process configuration:</p> <ul> <li>Standard EM physics (G4EmStandardPhysics)</li> <li>Step limiter for controlled tracking</li> <li>Maximum step size: 20 \u00b5m in silicon</li> </ul>"},{"location":"architecture/#steppingaction","title":"SteppingAction","text":"<p>File: <code>include/SteppingAction.hh</code>, <code>src/SteppingAction.cc</code></p> <p>Lightweight tracker for: - First-contact volume identification - Energy deposit accumulation - Hit classification (pixel vs silicon)</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#event-processing-pipeline","title":"Event Processing Pipeline","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Primary Vertex  \u2502\n\u2502   (x, y, z)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Particle Tracking\u2502\n\u2502  Energy Deposits \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Hit Position     \u2502\n\u2502 Determination    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         ChargeSharingCalculator              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 1. Find nearest pixel                  \u2502  \u2502\n\u2502  \u2502 2. Build neighborhood grid             \u2502  \u2502\n\u2502  \u2502 3. Compute distances d_i, angles \u03b1_i   \u2502  \u2502\n\u2502  \u2502 4. Calculate weights w_i (LogA/LinA)   \u2502  \u2502\n\u2502  \u2502 5. Normalize: F_i = w_i / \u03a3w_n         \u2502  \u2502\n\u2502  \u2502 6. Apply gain noise                    \u2502  \u2502\n\u2502  \u2502 7. Apply electronic noise              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Position Recon.  \u2502\n\u2502 (LogA/LinA/DPC)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  ROOT TTree      \u2502\n\u2502    Output        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#root-output-structure","title":"ROOT Output Structure","text":"<pre><code>epicChargeSharing.root\n\u251c\u2500\u2500 tree (TTree)\n\u2502   \u251c\u2500\u2500 Scalar Branches\n\u2502   \u2502   \u251c\u2500\u2500 TrueX, TrueY, TrueZ\n\u2502   \u2502   \u251c\u2500\u2500 PixelX, PixelY\n\u2502   \u2502   \u251c\u2500\u2500 ReconX, ReconY\n\u2502   \u2502   \u251c\u2500\u2500 Edep\n\u2502   \u2502   \u2514\u2500\u2500 Delta branches (residuals)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Classification Branches\n\u2502   \u2502   \u251c\u2500\u2500 isPixelHit\n\u2502   \u2502   \u251c\u2500\u2500 NeighborhoodSize\n\u2502   \u2502   \u2514\u2500\u2500 NearestPixel indices\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 Vector Branches (neighborhood)\n\u2502   \u2502   \u251c\u2500\u2500 Fi, Qi, Qn, Qf\n\u2502   \u2502   \u251c\u2500\u2500 d_i, alpha_i\n\u2502   \u2502   \u2514\u2500\u2500 Pixel coordinates\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 Full Grid Branches (optional)\n\u2502       \u2514\u2500\u2500 Complete detector maps\n\u2502\n\u2514\u2500\u2500 Metadata (TNamed objects)\n    \u251c\u2500\u2500 Geometry parameters\n    \u251c\u2500\u2500 Physics settings\n    \u251c\u2500\u2500 Noise configuration\n    \u2514\u2500\u2500 Reconstruction method\n</code></pre>"},{"location":"architecture/#threading-model","title":"Threading Model","text":"<p>epicChargeSharing supports GEANT4's multithreading when compiled with MT support.</p>"},{"location":"architecture/#architecture_1","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              G4MTRunManager                      \u2502\n\u2502                 (Master)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502               \u2502               \u2502\n    \u25bc               \u25bc               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Worker 0\u2502    \u2502Worker 1\u2502 ...  \u2502Worker N\u2502\n\u2502Thread  \u2502    \u2502Thread  \u2502      \u2502Thread  \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n     \u2502             \u2502               \u2502\n     \u25bc             \u25bc               \u25bc\nworker_0.root  worker_1.root  worker_N.root\n     \u2502             \u2502               \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u25bc (merge)\n           epicChargeSharing.root\n</code></pre>"},{"location":"architecture/#synchronization","title":"Synchronization","text":"<p>WorkerSync Class (<code>RootHelpers.hh</code>): - Atomic counter for worker registration - Condition variables for ordering - Mutex protection for file operations</p> <pre><code>struct WorkerSync {\n    std::atomic&lt;int&gt; workerCount{0};\n    std::mutex mutex;\n    std::condition_variable cv;\n\n    void RegisterWorker();\n    void WaitForAllWorkers();\n};\n</code></pre>"},{"location":"architecture/#thread-local-storage","title":"Thread-Local Storage","text":"<p>Each worker maintains: - Own EventAction instance - Own ChargeSharingCalculator - Own ROOT file handle - Own random number generator state</p>"},{"location":"architecture/#namespace-organization","title":"Namespace Organization","text":"<pre><code>ECS (Epic Charge Sharing)\n\u251c\u2500\u2500 Config\n\u2502   \u251c\u2500\u2500 SignalModel (LogA, LinA)\n\u2502   \u251c\u2500\u2500 ReconMethod (LogA, LinA, DPC)\n\u2502   \u251c\u2500\u2500 DenominatorMode (Neighborhood, ChargeBlock, RowCol)\n\u2502   \u251c\u2500\u2500 DetectorGeometry (struct)\n\u2502   \u251c\u2500\u2500 PhysicsParameters (struct)\n\u2502   \u251c\u2500\u2500 NoiseModel (struct)\n\u2502   \u251c\u2500\u2500 ReconstructionConfig (struct)\n\u2502   \u2514\u2500\u2500 GlobalConfig (struct)\n\u2502\n\u251c\u2500\u2500 DetectorConstruction\n\u251c\u2500\u2500 ActionInitialization\n\u251c\u2500\u2500 PhysicsList\n\u251c\u2500\u2500 PrimaryGenerator\n\u251c\u2500\u2500 EventAction\n\u251c\u2500\u2500 RunAction\n\u251c\u2500\u2500 SteppingAction\n\u251c\u2500\u2500 ChargeSharingCalculator\n\u2502   \u251c\u2500\u2500 PixelGridGeometry\n\u2502   \u251c\u2500\u2500 HitInfo\n\u2502   \u251c\u2500\u2500 ChargeMode\n\u2502   \u251c\u2500\u2500 Grid2D&lt;T&gt;\n\u2502   \u251c\u2500\u2500 ChargeMatrixSet\n\u2502   \u251c\u2500\u2500 FullGridCharges\n\u2502   \u251c\u2500\u2500 PatchInfo\n\u2502   \u251c\u2500\u2500 PatchGridCharges\n\u2502   \u2514\u2500\u2500 Result\n\u2502\n\u2514\u2500\u2500 (Utility classes)\n    \u251c\u2500\u2500 NeighborhoodLayout\n    \u251c\u2500\u2500 RootFileWriter\n    \u251c\u2500\u2500 WorkerSync\n    \u251c\u2500\u2500 BranchConfigurator\n    \u251c\u2500\u2500 TreeFiller\n    \u251c\u2500\u2500 MetadataPublisher\n    \u2514\u2500\u2500 PostProcessingRunner\n</code></pre>"},{"location":"architecture/#backward-compatibility","title":"Backward Compatibility","text":"<p>Global aliases maintain compatibility with older code:</p> <pre><code>// In global namespace\nusing DetectorConstruction = ECS::DetectorConstruction;\nusing ChargeSharingCalculator = ECS::ChargeSharingCalculator;\n// etc.\n\nnamespace Constants {\n    // Wraps ECS::Config values\n    inline constexpr auto DETECTOR_SIZE = ECS::Config::DetectorGeometry::Default().detectorSize;\n    // etc.\n}\n</code></pre>"},{"location":"architecture/#file-dependencies","title":"File Dependencies","text":"<pre><code>epicChargeSharing.cc\n    \u251c\u2500\u2500 DetectorConstruction.hh\n    \u251c\u2500\u2500 PhysicsList.hh\n    \u2514\u2500\u2500 ActionInitialization.hh\n            \u2514\u2500\u2500 PrimaryGenerator.hh\n            \u2514\u2500\u2500 RunAction.hh\n            \u2502       \u251c\u2500\u2500 RootIO.hh\n            \u2502       \u2502       \u251c\u2500\u2500 RootHelpers.hh\n            \u2502       \u2502       \u2514\u2500\u2500 Config.hh\n            \u2502       \u2514\u2500\u2500 NeighborhoodUtils.hh\n            \u2514\u2500\u2500 EventAction.hh\n            \u2502       \u2514\u2500\u2500 ChargeSharingCalculator.hh\n            \u2502               \u2514\u2500\u2500 Config.hh\n            \u2514\u2500\u2500 SteppingAction.hh\n</code></pre>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#adding-new-reconstruction-methods","title":"Adding New Reconstruction Methods","text":"<ol> <li> <p>Add enum value in <code>Config.hh</code>:    <pre><code>enum class ReconMethod { LogA, LinA, DPC, NewMethod };\n</code></pre></p> </li> <li> <p>Implement reconstruction in <code>EventAction.cc</code>:    <pre><code>case ReconMethod::NewMethod:\n    // Your algorithm\n    break;\n</code></pre></p> </li> </ol>"},{"location":"architecture/#adding-new-output-branches","title":"Adding New Output Branches","text":"<ol> <li> <p>Declare in <code>RunAction.hh</code>:    <pre><code>G4double fNewBranch;\n</code></pre></p> </li> <li> <p>Create branch in <code>RunAction::SetupBranches()</code>:    <pre><code>fTree-&gt;Branch(\"NewBranch\", &amp;fNewBranch);\n</code></pre></p> </li> <li> <p>Fill in <code>RunAction::FillTree()</code>:    <pre><code>fNewBranch = computedValue;\n</code></pre></p> </li> </ol>"},{"location":"architecture/#adding-new-physics-parameters","title":"Adding New Physics Parameters","text":"<ol> <li> <p>Add to struct in <code>Config.hh</code>:    <pre><code>struct PhysicsParameters {\n    G4double newParam = defaultValue;\n};\n</code></pre></p> </li> <li> <p>Add backward-compat alias:    <pre><code>namespace Constants {\n    inline constexpr G4double NEW_PARAM = ...;\n}\n</code></pre></p> </li> <li> <p>Update metadata publishing in <code>RootIO.cc</code></p> </li> </ol>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>This document provides a complete reference for all configuration parameters in epicChargeSharing.</p>"},{"location":"configuration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Configuration System</li> <li>Detector Geometry</li> <li>Physics Parameters</li> <li>Noise Model</li> <li>Reconstruction Settings</li> <li>Output Control</li> <li>Runtime Configuration</li> <li>Macro Commands</li> </ul>"},{"location":"configuration/#configuration-system","title":"Configuration System","text":"<p>Configuration is managed through <code>include/Config.hh</code> using a hierarchical struct-based system:</p> <pre><code>namespace ECS::Config {\n    struct DetectorGeometry { ... };\n    struct PhysicsParameters { ... };\n    struct NoiseModel { ... };\n    struct ReconstructionConfig { ... };\n    struct GlobalConfig { ... };  // Combined config\n}\n</code></pre> <p>Backward Compatibility: The <code>Constants</code> namespace wraps <code>ECS::Config</code> for legacy code:</p> <pre><code>namespace Constants {\n    inline const G4double DETECTOR_SIZE = 30.0 * mm;\n    // etc.\n}\n</code></pre>"},{"location":"configuration/#detector-geometry","title":"Detector Geometry","text":""},{"location":"configuration/#detectorgeometry-struct","title":"DetectorGeometry Struct","text":"Parameter Type Default Unit Description <code>detectorSize</code> G4double 30.0 mm Square detector side length <code>detectorThickness</code> G4double 0.05 mm Silicon substrate thickness <code>worldSize</code> G4double 5.0 cm World volume size <code>detectorZPosition</code> G4double -1.0 cm Z position of detector <code>pixelSize</code> G4double 0.1 mm Pixel pad side length <code>pixelThickness</code> G4double 0.001 mm Pixel pad thickness <code>pitch</code> G4double 0.5 mm Pixel center-to-center spacing <code>pixelCornerOffset</code> G4double 0.1 mm Distance from detector edge to first pixel <code>neighborhoodRadius</code> G4int 2 - Radius for charge sharing grid <code>storeFullGrid</code> G4bool true - Store full detector grid data <code>geometryTolerance</code> G4double 1.0 \u00b5m Geometry overlap tolerance <code>precisionTolerance</code> G4double 1.0 nm Numerical precision tolerance"},{"location":"configuration/#geometry-calculations","title":"Geometry Calculations","text":"<p>Pixels per side: <pre><code>pixelsPerSide = (detectorSize - 2 * pixelCornerOffset) / pitch + 1\n// Default: (30 - 0.2) / 0.5 + 1 = 60 pixels per side\n</code></pre></p> <p>Total pixels: <pre><code>totalPixels = pixelsPerSide * pixelsPerSide\n// Default: 60 \u00d7 60 = 3,600 pixels\n</code></pre></p> <p>Neighborhood size: <pre><code>neighborhoodSide = 2 * neighborhoodRadius + 1\n// Default: 2 \u00d7 2 + 1 = 5 (5\u00d75 = 25 pixels)\n</code></pre></p>"},{"location":"configuration/#constants-namespace-equivalents","title":"Constants Namespace Equivalents","text":"<pre><code>namespace Constants {\n    inline const G4double DETECTOR_SIZE = 30.0 * mm;\n    inline const G4double DETECTOR_WIDTH = 0.05 * mm;\n    inline const G4double PIXEL_SIZE = 0.1 * mm;\n    inline const G4double PIXEL_PITCH = 0.5 * mm;\n    inline const G4double PIXEL_CORNER_OFFSET = 0.1 * mm;\n    inline constexpr G4int NEIGHBORHOOD_RADIUS = 2;\n}\n</code></pre>"},{"location":"configuration/#physics-parameters","title":"Physics Parameters","text":""},{"location":"configuration/#physicsparameters-struct","title":"PhysicsParameters Struct","text":"Parameter Type Default Unit Description <code>ionizationEnergy</code> G4double 3.6 eV Energy per electron-hole pair in silicon <code>gain</code> G4double 20.0 - AC-LGAD amplification factor (typical: 8-25) <code>d0</code> G4double 1.0 \u00b5m Transverse hit size (Tornago Eq. 4) <code>elementaryCharge</code> G4double 1.602\u00d710\u207b\u00b9\u2079 C Electron charge <code>maxStepSize</code> G4double 20.0 \u00b5m Maximum step length in silicon <code>primaryParticleZ</code> G4double 0.0 cm Z position of particle gun"},{"location":"configuration/#charge-generation","title":"Charge Generation","text":"<p>Electron-hole pairs: <pre><code>pairs = (energyDeposit [MeV] \u00d7 10\u2076) / ionizationEnergy [eV]\n// For 10 GeV electron: ~2.8\u00d710\u2076 pairs\n</code></pre></p> <p>Amplified charge: <pre><code>amplifiedPairs = pairs \u00d7 gain\n// With gain 20: ~5.6\u00d710\u2077 effective electrons\n</code></pre></p>"},{"location":"configuration/#constants-namespace-equivalents_1","title":"Constants Namespace Equivalents","text":"<pre><code>namespace Constants {\n    inline constexpr G4double IONIZATION_ENERGY = 3.6;  // eV\n    inline constexpr G4double GAIN = 20.0;\n    inline constexpr G4double D0 = 1.0;  // \u00b5m\n    inline constexpr G4double ELEMENTARY_CHARGE = 1.602176634e-19;\n    inline const G4double MAX_STEP_SIZE = 20.0 * micrometer;\n}\n</code></pre>"},{"location":"configuration/#noise-model","title":"Noise Model","text":""},{"location":"configuration/#noisemodel-struct","title":"NoiseModel Struct","text":"Parameter Type Default Description <code>gainSigmaMin</code> G4double 0.010 Minimum gain noise \u03c3 (1%) <code>gainSigmaMax</code> G4double 0.050 Maximum gain noise \u03c3 (5%) <code>noiseElectronCount</code> G4double 500.0 Electronic noise in electrons <code>enablePositionDependence</code> G4bool false Position-dependent noise <code>edgeEffectWidth</code> G4double 10.0 Edge effect width (if enabled) <code>edgeNoiseMultiplier</code> G4double 1.5 Noise multiplier at edges <code>enableCrosstalk</code> G4bool false Enable pixel crosstalk <code>crosstalkFraction</code> G4double 0.02 Crosstalk fraction (2%)"},{"location":"configuration/#noise-application","title":"Noise Application","text":"<p>Gain noise (multiplicative, per-pixel): <pre><code>// Each pixel has a fixed \u03c3_gain randomly assigned between min and max\ncharge_with_noise = charge \u00d7 (1 + G4RandGauss(0, \u03c3_gain))\n</code></pre></p> <p>Electronic noise (additive): <pre><code>\u03c3_electronic = noiseElectronCount \u00d7 elementaryCharge\ncharge_final = max(0, charge_with_noise + G4RandGauss(0, \u03c3_electronic))\n</code></pre></p>"},{"location":"configuration/#constants-namespace-equivalents_2","title":"Constants Namespace Equivalents","text":"<pre><code>namespace Constants {\n    inline constexpr G4double PIXEL_GAIN_SIGMA_MIN = 0.010;\n    inline constexpr G4double PIXEL_GAIN_SIGMA_MAX = 0.050;\n    inline constexpr G4double NOISE_ELECTRON_COUNT = 500.0;\n}\n</code></pre>"},{"location":"configuration/#reconstruction-settings","title":"Reconstruction Settings","text":""},{"location":"configuration/#reconstructionconfig-struct","title":"ReconstructionConfig Struct","text":"Parameter Type Default Description <code>signalModel</code> SignalModel LogA Signal sharing model <code>reconMethod</code> ReconMethod DPC Position reconstruction method <code>denominatorMode</code> DenominatorMode Neighborhood Fraction normalization mode <code>dpcKx</code> G4double 0.478 mm DPC k coefficient for x <code>dpcKy</code> G4double 0.471 mm DPC k coefficient for y <code>dpcTopNPixels</code> G4int 4 Number of pixels for DPC (always 4) <code>linearBeta</code> G4double 0.003 LinA attenuation coefficient <code>emitDistanceAlpha</code> G4bool false Store d_i and \u03b1_i in output <code>runFitGaus1D</code> G4bool true Run 1D Gaussian fitting <code>runFitGaus2D</code> G4bool false Run 2D Gaussian fitting"},{"location":"configuration/#signal-models","title":"Signal Models","text":"Model Enum Value Formula LogA <code>SignalModel::LogA</code> <code>w_i = \u03b1_i / ln(d_i/d\u2080)</code> LinA <code>SignalModel::LinA</code> <code>w_i = \u03b1_i \u00d7 exp(-\u03b2 \u00d7 d_i)</code>"},{"location":"configuration/#reconstruction-methods","title":"Reconstruction Methods","text":"Method Enum Value Description LogA <code>ReconMethod::LogA</code> Chi-square fit using LogA model LinA <code>ReconMethod::LinA</code> Chi-square fit using LinA model DPC <code>ReconMethod::DPC</code> Direct position from 4-pixel charge ratios"},{"location":"configuration/#denominator-modes","title":"Denominator Modes","text":"Mode Enum Value Normalization Neighborhood <code>DenominatorMode::Neighborhood</code> <code>F_i = w_i / \u03a3_all(w_n)</code> RowCol <code>DenominatorMode::RowCol</code> Row: <code>\u03a3_row(w_n)</code>, Col: <code>\u03a3_col(w_n)</code> ChargeBlock <code>DenominatorMode::ChargeBlock</code> <code>F_i = w_i / \u03a3_4closest(w_n)</code>"},{"location":"configuration/#dpc-mode-behavior","title":"DPC Mode Behavior","text":"<p>When <code>reconMethod = ReconMethod::DPC</code>:</p> Feature Behavior Full grid storage Disabled (only 4 pixels needed) Gaussian fitting Disabled (DPC provides direct position) Signal model Uses <code>DPC_SIGNAL_MODEL</code> setting"},{"location":"configuration/#constants-namespace-equivalents_3","title":"Constants Namespace Equivalents","text":"<pre><code>namespace Constants {\n    inline constexpr ReconMethod RECON_METHOD = ReconMethod::DPC;\n    inline constexpr SignalModel DPC_SIGNAL_MODEL = SignalModel::LogA;\n    inline constexpr DenominatorMode DENOMINATOR_MODE = DenominatorMode::Neighborhood;\n    inline constexpr G4bool IS_DPC_MODE = (RECON_METHOD == ReconMethod::DPC);\n    inline const G4double DPC_KX = 0.478 * mm;\n    inline const G4double DPC_KY = 0.471 * mm;\n    inline constexpr G4int DPC_TOP_N_PIXELS = 4;\n    inline constexpr G4double LINEAR_CHARGE_MODEL_BETA = 0.001;\n}\n</code></pre>"},{"location":"configuration/#output-control","title":"Output Control","text":""},{"location":"configuration/#output-branches-by-mode","title":"Output Branches by Mode","text":"<p>DENOMINATOR_MODE controls which branches are saved:</p> Mode Branches Neighborhood Fi, Qi, Qn, Qf RowCol FiRow, FiCol, QiRow, QiCol, QnRow, QnCol, QfRow, QfCol ChargeBlock FiBlock, QiBlock, QnBlock, QfBlock"},{"location":"configuration/#full-grid-storage","title":"Full Grid Storage","text":"<p>STORE_FULL_GRID (automatically disabled in DPC mode):</p> Value Effect true Store complete detector grid arrays false Store only neighborhood data"},{"location":"configuration/#post-processing-control","title":"Post-Processing Control","text":"Setting Default Description <code>FIT_GAUS_1D</code> <code>!IS_DPC_MODE</code> Run 1D Gaussian fitting <code>FIT_GAUS_2D</code> false Run 2D Gaussian fitting"},{"location":"configuration/#runtime-configuration","title":"Runtime Configuration","text":""},{"location":"configuration/#g4messenger-commands","title":"G4Messenger Commands","text":"<p>Detector Configuration: <pre><code>/ecs/detector/pixelSize &lt;value&gt; &lt;unit&gt;\n/ecs/detector/pixelPitch &lt;value&gt; &lt;unit&gt;\n/ecs/detector/pixelCornerOffset &lt;value&gt; &lt;unit&gt;\n</code></pre></p> <p>Particle Gun Configuration: <pre><code>/ecs/gun/fixedPosition &lt;true|false&gt;\n/ecs/gun/fixedX &lt;value&gt;\n/ecs/gun/fixedY &lt;value&gt;\n</code></pre></p>"},{"location":"configuration/#examples","title":"Examples","text":"<pre><code># Set pixel pitch to 400 \u00b5m\n/ecs/detector/pixelPitch 0.4 mm\n\n# Use fixed position mode\n/ecs/gun/fixedPosition true\n/ecs/gun/fixedX 0.125 mm\n/ecs/gun/fixedY 0.125 mm\n</code></pre>"},{"location":"configuration/#macro-commands","title":"Macro Commands","text":""},{"location":"configuration/#standard-geant4-commands","title":"Standard GEANT4 Commands","text":"<p>Verbosity Control: <pre><code>/control/verbose &lt;0-2&gt;\n/run/verbose &lt;0-2&gt;\n/event/verbose &lt;0-2&gt;\n/tracking/verbose &lt;0-2&gt;\n</code></pre></p> <p>Initialization: <pre><code>/run/initialize\n</code></pre></p> <p>Particle Gun: <pre><code>/gun/particle &lt;particle_name&gt;\n/gun/energy &lt;value&gt; &lt;unit&gt;\n/gun/position &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;unit&gt;\n/gun/direction &lt;dx&gt; &lt;dy&gt; &lt;dz&gt;\n</code></pre></p> <p>Run Control: <pre><code>/run/beamOn &lt;nEvents&gt;\n</code></pre></p>"},{"location":"configuration/#example-macro-files","title":"Example Macro Files","text":"<p>Batch Run (<code>macros/run.mac</code>): <pre><code>/control/verbose 0\n/run/verbose 0\n/event/verbose 0\n/tracking/verbose 0\n\n/run/initialize\n\n/gun/particle e-\n/gun/energy 10 GeV\n\n/run/beamOn 10000\n</code></pre></p> <p>Position Sweep: <pre><code>/control/verbose 0\n/run/verbose 0\n/run/initialize\n\n/gun/particle e-\n/gun/energy 10 GeV\n\n# Enable fixed position mode\n/ecs/gun/fixedPosition true\n\n# Sweep across positions\n/ecs/gun/fixedX 0.0 mm\n/ecs/gun/fixedY 0.0 mm\n/run/beamOn 1000\n\n/ecs/gun/fixedX 0.125 mm\n/ecs/gun/fixedY 0.0 mm\n/run/beamOn 1000\n\n# Continue sweep...\n</code></pre></p> <p>Visualization (<code>macros/vis.mac</code>): <pre><code>/vis/open OGL 800x600-0+0\n/vis/drawVolume\n/vis/viewer/set/viewpointVector 1 1 1\n/vis/viewer/set/autoRefresh true\n/vis/scene/add/trajectories smooth\n/vis/scene/add/hits\n/vis/scene/endOfEventAction accumulate\n</code></pre></p>"},{"location":"configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"configuration/#high-resolution-study","title":"High-Resolution Study","text":"<pre><code>// In Config.hh - modify defaults\nstruct DetectorGeometry {\n    G4double pixelSize = 0.05 * mm;       // Smaller pixels\n    G4double pitch = 0.25 * mm;           // Tighter pitch\n    G4int neighborhoodRadius = 3;         // Larger neighborhood\n    G4bool storeFullGrid = true;\n};\n\nstruct ReconstructionConfig {\n    ReconMethod reconMethod = ReconMethod::LogA;  // Chi-square fit\n    G4bool runFitGaus1D = true;\n    G4bool runFitGaus2D = true;\n};\n</code></pre>"},{"location":"configuration/#fast-dpc-analysis","title":"Fast DPC Analysis","text":"<pre><code>// In Config.hh - DPC mode (default)\nstruct ReconstructionConfig {\n    SignalModel signalModel = SignalModel::LogA;\n    ReconMethod reconMethod = ReconMethod::DPC;\n    // Full grid and fitters automatically disabled\n};\n</code></pre>"},{"location":"configuration/#noise-study","title":"Noise Study","text":"<pre><code>// In Config.hh - enhanced noise modeling\nstruct NoiseModel {\n    G4double gainSigmaMin = 0.02;         // Higher min noise\n    G4double gainSigmaMax = 0.10;         // Higher max noise\n    G4double noiseElectronCount = 1000.0; // More electronic noise\n    G4bool enablePositionDependence = true;\n    G4bool enableCrosstalk = true;\n};\n</code></pre>"},{"location":"configuration/#changing-configuration","title":"Changing Configuration","text":""},{"location":"configuration/#compile-time-changes","title":"Compile-Time Changes","text":"<ol> <li>Edit <code>include/Config.hh</code></li> <li>Modify struct defaults or <code>Constants</code> namespace values</li> <li>Rebuild:    <pre><code>cd build\nmake -j$(nproc)\n</code></pre></li> </ol>"},{"location":"configuration/#runtime-changes-limited","title":"Runtime Changes (Limited)","text":"<p>Some parameters can be changed via G4Messenger commands before <code>/run/initialize</code>:</p> <pre><code>./epicChargeSharing\n/ecs/detector/pixelPitch 0.4 mm\n/run/initialize\n/run/beamOn 1000\n</code></pre> <p>Note: Most physics parameters require recompilation.</p>"},{"location":"configuration/#quick-reference","title":"Quick Reference","text":""},{"location":"configuration/#reconstruction-method-selection","title":"Reconstruction Method Selection","text":"Goal Setting Fast position reconstruction <code>RECON_METHOD = DPC</code> Best resolution (slow) <code>RECON_METHOD = LogA</code> Alternative attenuation <code>RECON_METHOD = LinA</code>"},{"location":"configuration/#output-size-control","title":"Output Size Control","text":"Goal Settings Minimal output <code>STORE_FULL_GRID = false</code>, <code>DENOMINATOR_MODE = Neighborhood</code> Full analysis <code>STORE_FULL_GRID = true</code>, <code>emitDistanceAlpha = true</code> Row/Col fitting <code>DENOMINATOR_MODE = RowCol</code>"},{"location":"configuration/#noise-level-control","title":"Noise Level Control","text":"Goal Settings Ideal (no noise) <code>gainSigmaMin = gainSigmaMax = 0</code>, <code>noiseElectronCount = 0</code> Realistic Use defaults High noise study Increase <code>gainSigmaMax</code>, <code>noiseElectronCount</code>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing, building, and running your first epicChargeSharing simulation.</p>"},{"location":"getting-started/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Installation</li> <li>Building</li> <li>Your First Simulation</li> <li>Understanding the Output</li> <li>Next Steps</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/#required-software","title":"Required Software","text":"Software Minimum Version Installation GEANT4 11.0 geant4.web.cern.ch ROOT 6.20 root.cern CMake 3.9 Package manager or cmake.org C++ Compiler C++20 support GCC 10+, Clang 10+, or MSVC 2019+"},{"location":"getting-started/#installing-geant4","title":"Installing GEANT4","text":"<pre><code># Download and extract GEANT4\nwget https://geant4-data.web.cern.ch/releases/geant4-v11.2.0.tar.gz\ntar xzf geant4-v11.2.0.tar.gz\ncd geant4-v11.2.0\n\n# Build\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_INSTALL_PREFIX=/opt/geant4 \\\n      -DGEANT4_USE_QT=ON \\\n      -DGEANT4_INSTALL_DATA=ON \\\n      -DGEANT4_USE_OPENGL_X11=ON \\\n      ..\nmake -j$(nproc)\nsudo make install\n\n# Source environment\nsource /opt/geant4/bin/geant4.sh\n</code></pre>"},{"location":"getting-started/#installing-root","title":"Installing ROOT","text":"<pre><code># Using package manager (Ubuntu/Debian)\nsudo apt install root-system\n\n# Or from source\nwget https://root.cern/download/root_v6.30.00.source.tar.gz\ntar xzf root_v6.30.00.source.tar.gz\ncd root-6.30.00\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\nsource bin/thisroot.sh\n</code></pre>"},{"location":"getting-started/#verifying-prerequisites","title":"Verifying Prerequisites","text":"<pre><code># Check GEANT4\ngeant4-config --version\n# Should show: 11.x.x\n\n# Check ROOT\nroot-config --version\n# Should show: 6.xx/xx\n\n# Check CMake\ncmake --version\n# Should show: cmake version 3.x.x\n\n# Check compiler\ng++ --version\n# Should show: g++ (GCC) 10.x.x or higher\n</code></pre>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/tom-bleher/epicChargeSharing.git\ncd epicChargeSharing\n</code></pre>"},{"location":"getting-started/#project-structure-overview","title":"Project Structure Overview","text":"<pre><code>epicChargeSharing/\n\u251c\u2500\u2500 epicChargeSharing.cc    # Main program entry\n\u251c\u2500\u2500 CMakeLists.txt          # Build configuration\n\u251c\u2500\u2500 include/                # Header files\n\u251c\u2500\u2500 src/                    # Source files\n\u251c\u2500\u2500 macros/                 # GEANT4 macro files\n\u2502   \u251c\u2500\u2500 run.mac             # Batch execution\n\u2502   \u2514\u2500\u2500 vis.mac             # Visualization\n\u251c\u2500\u2500 farm/                   # Analysis scripts\n\u251c\u2500\u2500 proc/                   # ROOT macros\n\u2514\u2500\u2500 docs/                   # Documentation\n</code></pre>"},{"location":"getting-started/#building","title":"Building","text":""},{"location":"getting-started/#standard-build","title":"Standard Build","text":"<pre><code># Create build directory\nmkdir build\ncd build\n\n# Configure\ncmake -DCMAKE_BUILD_TYPE=Release ..\n\n# Build (use all available cores)\nmake -j$(nproc)\n</code></pre> <p>Expected output: <pre><code>-- The CXX compiler identification is GNU 11.4.0\n-- Found Geant4 11.2.0\n-- Found ROOT 6.30/00\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /path/to/epicChargeSharing/build\n\n[100%] Built target epicChargeSharing\n</code></pre></p>"},{"location":"getting-started/#build-with-additional-options","title":"Build with Additional Options","text":"<pre><code># Debug build (for development)\ncmake -DCMAKE_BUILD_TYPE=Debug ..\n\n# With unit tests\ncmake -DBUILD_TESTING=ON ..\nmake -j$(nproc)\nctest\n\n# With fast math optimizations\ncmake -DEC_FAST_MATH=ON ..\n\n# Generate Doxygen documentation\nmake docs\n</code></pre>"},{"location":"getting-started/#troubleshooting-build-issues","title":"Troubleshooting Build Issues","text":"<p>GEANT4 not found: <pre><code># Set GEANT4 path explicitly\ncmake -DGeant4_DIR=/opt/geant4/lib/cmake/Geant4 ..\n</code></pre></p> <p>ROOT not found: <pre><code># Source ROOT environment first\nsource /path/to/root/bin/thisroot.sh\ncmake ..\n</code></pre></p> <p>C++20 not supported: <pre><code># Use a newer compiler\nexport CXX=/usr/bin/g++-11\ncmake ..\n</code></pre></p>"},{"location":"getting-started/#your-first-simulation","title":"Your First Simulation","text":""},{"location":"getting-started/#step-1-run-the-simulation","title":"Step 1: Run the Simulation","text":"<pre><code># From the build directory\n./epicChargeSharing -m ../macros/run.mac\n</code></pre> <p>You should see output like: <pre><code>**************************************************************\n Geant4 version Name: geant4-11-02-patch-01    (16-February-2024)\n**************************************************************\n\n### Run 0 started.\n--&gt; Event 0\n--&gt; Event 1000\n--&gt; Event 2000\n...\n--&gt; Event 9000\n### Run 0 finished. 10000 events processed.\n</code></pre></p>"},{"location":"getting-started/#step-2-check-the-output","title":"Step 2: Check the Output","text":"<p>The simulation creates <code>epicChargeSharing.root</code>:</p> <pre><code>ls -la epicChargeSharing.root\n# -rw-r--r-- 1 user user 5.2M Dec  5 12:00 epicChargeSharing.root\n</code></pre>"},{"location":"getting-started/#step-3-quick-inspection","title":"Step 3: Quick Inspection","text":"<pre><code># Open ROOT and inspect\nroot -l epicChargeSharing.root\n</code></pre> <pre><code>// In ROOT prompt\n.ls                              // List file contents\ntree-&gt;Print()                    // Show all branches\ntree-&gt;GetEntries()               // Number of events (should be 10000)\ntree-&gt;Draw(\"ReconTrueDeltaX\")    // Plot X residual\n</code></pre>"},{"location":"getting-started/#step-4-simple-analysis","title":"Step 4: Simple Analysis","text":"<p>Create a quick resolution plot:</p> <pre><code>// Still in ROOT\nTH1F* h = new TH1F(\"h\", \"X Resolution;#DeltaX (mm);Events\", 100, -0.1, 0.1);\ntree-&gt;Draw(\"ReconTrueDeltaX&gt;&gt;h\");\nh-&gt;Fit(\"gaus\");\n\n// Get resolution\nTF1* fit = h-&gt;GetFunction(\"gaus\");\ndouble sigma = fit-&gt;GetParameter(2);\ncout &lt;&lt; \"Resolution: \" &lt;&lt; sigma*1000 &lt;&lt; \" um\" &lt;&lt; endl;\n</code></pre>"},{"location":"getting-started/#understanding-the-output","title":"Understanding the Output","text":""},{"location":"getting-started/#root-file-contents","title":"ROOT File Contents","text":"<pre><code>// List all objects in file\nTFile f(\"epicChargeSharing.root\");\nf.ls();\n</code></pre> <p>Output: <pre><code>TFile**         epicChargeSharing.root\n TFile*         epicChargeSharing.root\n  KEY: TTree    tree;1  Simulation Results\n  KEY: TNamed   ChargeSharingModel;1\n  KEY: TNamed   DenominatorMode;1\n  KEY: TNamed   Gain;1\n  ...\n</code></pre></p>"},{"location":"getting-started/#key-branches-explained","title":"Key Branches Explained","text":"Branch What it Contains <code>TrueX</code>, <code>TrueY</code> Where the particle actually hit (truth) <code>ReconX</code>, <code>ReconY</code> Where we reconstructed the hit <code>ReconTrueDeltaX</code> Difference: ReconX - TrueX <code>Fi</code> Charge fraction on each pixel (vector) <code>isPixelHit</code> Did particle hit a pixel directly?"},{"location":"getting-started/#reading-metadata","title":"Reading Metadata","text":"<pre><code>// Read simulation parameters\nTNamed* model = (TNamed*)f.Get(\"ChargeSharingModel\");\ncout &lt;&lt; \"Model: \" &lt;&lt; model-&gt;GetTitle() &lt;&lt; endl;\n\nTNamed* gain = (TNamed*)f.Get(\"Gain\");\ncout &lt;&lt; \"Gain: \" &lt;&lt; gain-&gt;GetTitle() &lt;&lt; endl;\n</code></pre>"},{"location":"getting-started/#command-line-options","title":"Command Line Options","text":"<pre><code>./epicChargeSharing [options]\n\nOptions:\n  -m &lt;macro&gt;    Run in batch mode with specified macro file (required)\n  -t &lt;threads&gt;  Number of threads for parallel execution\n</code></pre>"},{"location":"getting-started/#examples","title":"Examples","text":"<pre><code># Basic batch run\n./epicChargeSharing -m ../macros/run.mac\n\n# Multi-threaded (4 cores)\n./epicChargeSharing -m ../macros/run.mac -t 4\n\n# Interactive mode (no macro)\n./epicChargeSharing\n# Then type commands manually\n</code></pre>"},{"location":"getting-started/#modifying-the-simulation","title":"Modifying the Simulation","text":""},{"location":"getting-started/#change-number-of-events","title":"Change Number of Events","text":"<p>Edit <code>macros/run.mac</code>: <pre><code>/run/beamOn 100000    # Change from 10000 to 100000\n</code></pre></p>"},{"location":"getting-started/#change-particle-type","title":"Change Particle Type","text":"<p>Edit <code>macros/run.mac</code>: <pre><code>/gun/particle proton  # Instead of e-\n/gun/energy 1 GeV     # Adjust energy\n</code></pre></p>"},{"location":"getting-started/#change-detector-configuration","title":"Change Detector Configuration","text":"<p>Edit <code>include/Config.hh</code> and rebuild: <pre><code>// Change pixel pitch\ninline const G4double PIXEL_PITCH = 0.4 * mm;  // Was 0.5 mm\n\n// Change reconstruction method\ninline constexpr ReconMethod RECON_METHOD = ReconMethod::LogA;  // Was DPC\n</code></pre></p> <p>Then rebuild: <pre><code>cd build\nmake -j$(nproc)\n</code></pre></p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first simulation, explore:</p> <ol> <li>Configuration Guide: Learn all configurable parameters</li> <li>Physics Model: Understand the underlying physics</li> <li>Analysis Guide: Analyze your results</li> <li>Architecture: Understand the code structure</li> </ol>"},{"location":"getting-started/#try-these-exercises","title":"Try These Exercises","text":"<ol> <li> <p>Resolution Study: Run with 100,000 events and measure the position resolution</p> </li> <li> <p>Particle Comparison: Compare resolution for electrons vs protons</p> </li> <li> <p>Position Sweep: Run at multiple fixed positions:    <pre><code># Generate sweep macros\npython3 farm/sweep_x.py --start -250 --end 250 --step 50\n</code></pre></p> </li> <li> <p>Visualization: Try interactive mode with visualization:    <pre><code>./epicChargeSharing\n/control/execute ../macros/vis.mac\n/run/beamOn 10\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: See <code>docs/</code> directory</li> <li>Issues: GitHub Issues</li> <li>Email: tombleher@tauex.tau.ac.il</li> </ul>"},{"location":"getting-started/#quick-reference-card","title":"Quick Reference Card","text":"<pre><code># Build\nmkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j$(nproc)\n\n# Run simulation\n./epicChargeSharing -m ../macros/run.mac\n\n# Quick analysis\nroot -l epicChargeSharing.root\ntree-&gt;Draw(\"ReconTrueDeltaX\")\n\n# Check resolution\nTH1F h(\"h\",\"\",100,-0.1,0.1); tree-&gt;Draw(\"ReconTrueDeltaX&gt;&gt;h\"); h.Fit(\"gaus\")\n\n# Python analysis\npython3 ../farm/Fi_x.py --input-dir .\n</code></pre>"},{"location":"physics-model/","title":"Physics Model","text":"<p>This document describes the physics underlying the epicChargeSharing simulation, based on the AC-LGAD charge sharing model from Tornago et al. (arXiv:2007.09528).</p>"},{"location":"physics-model/#table-of-contents","title":"Table of Contents","text":"<ul> <li>AC-LGAD Detector Principle</li> <li>Charge Generation</li> <li>Charge Sharing Model</li> <li>Position Reconstruction</li> <li>Noise Modeling</li> <li>Implementation Details</li> </ul>"},{"location":"physics-model/#ac-lgad-detector-principle","title":"AC-LGAD Detector Principle","text":""},{"location":"physics-model/#what-is-an-ac-lgad","title":"What is an AC-LGAD?","text":"<p>AC-LGAD (Resistive AC-Coupled Low Gain Avalanche Detector) is a silicon detector technology that combines:</p> <ol> <li>Low Gain Avalanche Diode (LGAD): Internal multiplication layer providing gain (~8-25\u00d7)</li> <li>AC Coupling: Capacitive readout that spreads signal across multiple pads</li> <li>Resistive Layer: Enables charge sharing between neighboring electrodes</li> </ol> <pre><code>                    Incident Particle\n                           \u2502\n                           \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502           Metal Pads (Al)                \u2502  \u2190 Readout electrodes\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502        Resistive n+ Layer                \u2502  \u2190 Charge spreading\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502           p-type Bulk                    \u2502  \u2190 Active volume\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502         Multiplication Layer             \u2502  \u2190 Gain (~20\u00d7)\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502           p+ Substrate                   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"physics-model/#why-charge-sharing","title":"Why Charge Sharing?","text":"<p>In AC-LGADs, the signal induced on a metal pad depends on:</p> <ul> <li>Distance from the hit position to the pad</li> <li>Solid angle subtended by the pad</li> <li>Resistive layer properties</li> </ul> <p>This allows sub-pixel position resolution by analyzing charge ratios.</p>"},{"location":"physics-model/#charge-generation","title":"Charge Generation","text":""},{"location":"physics-model/#ionization-in-silicon","title":"Ionization in Silicon","text":"<p>When a charged particle traverses silicon, it creates electron-hole pairs:</p> \\[ N_{\\text{pairs}} = \\frac{E_{\\text{dep}}}{\\varepsilon} \\] <p>Where:</p> <ul> <li>\\(E_{\\text{dep}}\\) = Energy deposited (typically ~100 keV/\u00b5m for MIPs)</li> <li>\\(\\varepsilon\\) = 3.6 eV (ionization energy in silicon)</li> </ul> <p>Example: 10 GeV electron depositing 10 MeV creates ~2.8 million e-h pairs.</p>"},{"location":"physics-model/#signal-amplification","title":"Signal Amplification","text":"<p>The LGAD gain layer provides internal amplification:</p> \\[ N_{\\text{amplified}} = N_{\\text{pairs}} \\times G \\] <p>Where:</p> <ul> <li>\\(G\\) = Gain factor (default: 20)</li> <li>Typical range: 8-25 for AC-LGADs</li> </ul>"},{"location":"physics-model/#total-charge","title":"Total Charge","text":"<p>The total induced charge is:</p> \\[ Q_{\\text{total}} = N_{\\text{amplified}} \\times e = \\frac{E_{\\text{dep}}}{\\varepsilon} \\times G \\times e \\] <p>Where \\(e = 1.602 \\times 10^{-19}\\) C.</p>"},{"location":"physics-model/#charge-sharing-model","title":"Charge Sharing Model","text":""},{"location":"physics-model/#tornago-model-eq-4","title":"Tornago Model (Eq. 4)","text":"<p>The fraction of total signal amplitude on pad \\(i\\) is given by:</p> \\[ F_i = \\frac{\\alpha_i / \\ln(d_i / d_0)}{\\sum_n \\alpha_n / \\ln(d_n / d_0)} \\] <p>Where:</p> <ul> <li>\\(F_i\\) = Signal fraction on pad \\(i\\) (normalized: \\(\\sum F_i = 1\\))</li> <li>\\(\\alpha_i\\) = Angle of view of pad \\(i\\) from the hit position</li> <li>\\(d_i\\) = Distance from hit to pad \\(i\\) (to nearest edge)</li> <li>\\(d_0\\) = Transverse hit size (characteristic length, ~1 \u00b5m)</li> </ul>"},{"location":"physics-model/#physical-interpretation","title":"Physical Interpretation","text":"<p>Angle of View (\\(\\alpha_i\\)): The solid angle subtended by the pad:</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502   Pad i    \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502 \u03b1\u1d62\n                  \u2502/\n            \u2500\u2500\u2500\u2500\u2500\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500 Hit position\n</code></pre> <p>Distance Dependence: The logarithmic term \\(\\ln(d_i/d_0)\\) models the attenuation of the induced signal with distance. Pads closer to the hit receive more signal.</p>"},{"location":"physics-model/#linear-attenuation-model-lina","title":"Linear Attenuation Model (LinA)","text":"<p>An alternative model uses exponential attenuation (Tornago Eq. 6):</p> \\[ w_i = \\alpha_i \\times \\exp(-\\beta \\times d_i) \\] <p>Where \\(\\beta\\) = Attenuation coefficient (default: 0.001-0.003 \u00b5m\u207b\u00b9).</p> <p>The LinA model may better describe certain detector geometries.</p>"},{"location":"physics-model/#position-reconstruction","title":"Position Reconstruction","text":""},{"location":"physics-model/#logalina-reconstruction-chi-square-fit","title":"LogA/LinA Reconstruction (Chi-Square Fit)","text":"<p>For LogA and LinA methods, position is reconstructed by minimizing:</p> \\[ \\chi^2 = \\sum_i \\frac{(F_i^{\\text{measured}} - F_i^{\\text{model}}(x,y))^2}{\\sigma_i^2} \\] <p>Process:</p> <ol> <li>Measure charge fractions \\(F_i\\) on each pad</li> <li>Scan candidate positions \\((x, y)\\)</li> <li>Calculate model fractions \\(F_i^{\\text{model}}\\) at each position</li> <li>Find \\((x, y)\\) that minimizes \\(\\chi^2\\)</li> </ol>"},{"location":"physics-model/#dpc-reconstruction-discretized-positioning-circuit","title":"DPC Reconstruction (Discretized Positioning Circuit)","text":"<p>DPC uses only the 4 closest pads to the hit position (Tornago Section 3.4):</p> <pre><code>          \u2502 Pad 1 \u2502 Pad 2 \u2502\n          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502 Pad 3 \u2502\u25cfPad 4 \u2502  \u2190 Hit near Pad 4\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Position calculation:</p> \\[ x_{\\text{reco}} = x_{\\text{centroid}} + k_x \\times R_x \\] \\[ y_{\\text{reco}} = y_{\\text{centroid}} + k_y \\times R_y \\] <p>Where:</p> <ul> <li>\\(x_{\\text{centroid}}\\), \\(y_{\\text{centroid}}\\) = Center of the 4-pad block</li> <li>\\(k_x\\), \\(k_y\\) = Calibration constants</li> <li>\\(R_x\\), \\(R_y\\) = Charge imbalance ratios</li> </ul> <p>Charge ratios:</p> \\[ R_x = \\frac{(Q_2 + Q_4) - (Q_1 + Q_3)}{Q_1 + Q_2 + Q_3 + Q_4} \\] \\[ R_y = \\frac{(Q_1 + Q_2) - (Q_3 + Q_4)}{Q_1 + Q_2 + Q_3 + Q_4} \\]"},{"location":"physics-model/#method-comparison","title":"Method Comparison","text":"Method Speed Resolution Use Case LogA Slow (fitting) Best High-precision studies LinA Slow (fitting) Good Alternative attenuation DPC Fast (direct) Good Real-time reconstruction"},{"location":"physics-model/#noise-modeling","title":"Noise Modeling","text":""},{"location":"physics-model/#gain-noise-multiplicative","title":"Gain Noise (Multiplicative)","text":"<p>Each pixel has intrinsic gain variations:</p> \\[ Q_{\\text{noisy}} = Q_{\\text{ideal}} \\times (1 + \\mathcal{N}(0, \\sigma_{\\text{gain}})) \\] <p>Where:</p> <ul> <li>\\(\\sigma_{\\text{gain}}\\) = Per-pixel gain noise (randomly assigned between 1-5%)</li> <li>Different pixels have different noise levels</li> </ul>"},{"location":"physics-model/#electronic-noise-additive","title":"Electronic Noise (Additive)","text":"<p>Electronic readout noise adds Gaussian fluctuations:</p> \\[ Q_{\\text{final}} = Q_{\\text{noisy}} + \\mathcal{N}(0, \\sigma_{\\text{electronic}}) \\] <p>Where:</p> <ul> <li>\\(\\sigma_{\\text{electronic}} = N_{\\text{electrons}} \\times e\\)</li> <li>Default: 500 electrons (~80 fC)</li> </ul>"},{"location":"physics-model/#combined-effect","title":"Combined Effect","text":"\\[ Q_{\\text{final}} = \\max(0, Q_{\\text{ideal}} \\times (1 + \\delta_{\\text{gain}}) + \\delta_{\\text{electronic}}) \\] <p>The \\(\\max(0, \\ldots)\\) ensures non-negative charges (physical constraint).</p>"},{"location":"physics-model/#implementation-details","title":"Implementation Details","text":""},{"location":"physics-model/#coordinate-system","title":"Coordinate System","text":"<pre><code>              Y\n              \u2191\n              \u2502\n        \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500 X\n              \u2502\n\n    Pixel (0,0) at corner offset from detector edge\n</code></pre> <p>Pixel center coordinates:</p> \\[ x_i = \\text{pixelCornerOffset} + i \\times \\text{pitch} \\] \\[ y_j = \\text{pixelCornerOffset} + j \\times \\text{pitch} \\]"},{"location":"physics-model/#neighborhood-definition","title":"Neighborhood Definition","text":"<p>For neighborhood radius \\(r\\), the grid is \\((2r+1) \\times (2r+1)\\):</p> <pre><code>    r = 2 \u2192 5\u00d75 grid (25 pixels)\n\n    \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n    \u2502-2 \u2502-2 \u2502-2 \u2502-2 \u2502-2 \u2502  Row offset from center\n    \u2502-2 \u2502-1 \u2502 0 \u2502+1 \u2502+2 \u2502  Column offset\n    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    \u2502   \u2502   \u2502 \u25cf \u2502   \u2502   \u2502  \u2190 Center (nearest pixel)\n    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n    \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n    \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n    \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"physics-model/#distance-calculation","title":"Distance Calculation","text":"<p>Distance from hit position to pixel \\(i\\):</p> \\[ d_i = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2} \\] <p>Where \\(\\Delta x = x_{\\text{hit}} - x_{\\text{pixel},i}\\) and \\(\\Delta y = y_{\\text{hit}} - y_{\\text{pixel},i}\\).</p> <p>Clamped to avoid singularity: \\(d_i = \\max(d_i, d_0 \\times \\text{guardFactor})\\)</p>"},{"location":"physics-model/#angle-of-view-calculation","title":"Angle of View Calculation","text":"<p>Solid angle approximation for rectangular pads:</p> \\[ \\alpha_i \\approx \\frac{w_{\\text{pixel}} \\times h_{\\text{pixel}}}{4\\pi \\times d_i^2} \\] <p>For more accurate calculation at close range:</p> \\[ \\alpha_i = \\arctan\\left(\\frac{\\text{pixelSize}/2}{d_i}\\right) \\]"},{"location":"physics-model/#fraction-normalization-modes","title":"Fraction Normalization Modes","text":"<p>Neighborhood Mode:</p> \\[ F_i = \\frac{w_i}{\\sum_{\\text{neighborhood}} w_n} \\] <p>Row/Column Mode (for 1D fitting):</p> \\[ F_i^{\\text{row}} = \\frac{w_i}{\\sum_{\\text{same row}} w_n}, \\quad F_i^{\\text{col}} = \\frac{w_i}{\\sum_{\\text{same col}} w_n} \\] <p>Block Mode (for DPC):</p> \\[ F_i^{\\text{block}} = \\frac{w_i}{\\sum_{\\text{4 closest}} w_n} \\]"},{"location":"physics-model/#special-values","title":"Special Values","text":"Value Meaning <code>-999.0</code> Out-of-bounds or invalid fraction <code>NaN</code> Uninitialized value <code>-1</code> Invalid pixel ID/index"},{"location":"physics-model/#validation","title":"Validation","text":""},{"location":"physics-model/#expected-behavior","title":"Expected Behavior","text":"<ol> <li>Central pixel: Highest charge fraction (~30-50% for typical geometry)</li> <li>Adjacent pixels: Significant signal (~10-20%)</li> <li>Distant pixels: Small but non-zero signal</li> <li>Sum of fractions: Exactly 1.0 (by construction)</li> </ol>"},{"location":"physics-model/#resolution-scaling","title":"Resolution Scaling","text":"<p>Theoretical position resolution scales as:</p> \\[ \\sigma_{\\text{position}} \\propto \\frac{\\text{pitch}}{\\text{SNR}} \\] <p>Where:</p> <ul> <li>pitch = Pixel pitch (default: 500 \u00b5m)</li> <li>SNR = Signal-to-noise ratio</li> </ul>"},{"location":"physics-model/#dpc-resolution","title":"DPC Resolution","text":"<p>For DPC reconstruction:</p> \\[ \\sigma_{\\text{DPC}} \\approx \\frac{\\text{pitch}}{4 \\times \\text{SNR}} \\] <p>Typical: ~10-50 \u00b5m for standard AC-LGAD configurations.</p>"},{"location":"physics-model/#references","title":"References","text":"<ol> <li> <p>Tornago et al. \"Resistive AC-Coupled Silicon Detectors: principles of operation and first results from a combined analysis of beam test and laser data,\" arXiv:2007.09528 (2021).</p> </li> <li> <p>LGAD Collaboration papers on AC-LGAD development and characterization.</p> </li> <li> <p>GEANT4 Physics Reference Manual for particle transport in silicon.</p> </li> </ol>"}]}